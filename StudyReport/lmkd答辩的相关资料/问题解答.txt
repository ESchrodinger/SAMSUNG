	通过 ro.config.low_ram 属性来划分低内存设备和高性能设备
	低内存设备：中等内存压力出现得比较常见，杀进程主要针对 medium 和 critical 内存压力情况，配置 oom_adj_score，内存压力基于 swap 使用情况。杀进程策略会延迟，尽量保持服务处于运行中的状态。
	高性能设备：优先考虑性能和尽可能留有更多内存来优化用户体验。杀的策略会提前，一次会杀多个进程以保证内存处于低压力状态，更加激进地释放内存以保持系统处于低内存压力的状态。

1、psi全称？谁做的？linux什么时候加上的
Psi 全称Pressure Stall Information（内核压力失速信息）提供了一种评估系统资源压力的方法，

2、psi对比vmpressure的优势是什么，或者为什么使用psi
Vmpressure 也有一些缺陷：
- 结果仅体现内存回收压力，不能反映系统在申请内存上的资源等待时间
- 计算周期比较粗
- 粗略的几个等级通知，无法精细化管理
通过这些阻塞占比数据，我们可以看到短期以及中长期一段时间内各种资源的压力情况，可以较精确的确定时延抖动原因，并制定对应的负载管理策略。

3、lmkd是什么时候引入的，为什么用lmkd，而不用以前内核方式的lmk
Android 10及以后引入LMKD，
LMK缺点
	对于低内存设备，必须主动进行调整，即便如此，在处理涉及支持大文件的活跃页面缓存的工作负载时，性能比较差，性能不良会导致出现抖动，但是不会终止该进程。
	LMK 内核驱动程序一栏与可用内存限制，不会根据内存压力进行扩缩。
	由于设计的严格性，合作伙伴通常会自定义该驱动程序，使其可以在自己的设备上使用。
	LMK 驱动程序已挂接到 Slab Shrinker API，该 API 并非为了执行繁重操作（例如搜索并终止目标）而设计，这类操作会导致 vmscan 进程变慢。

4、epoll的原理是啥，跟poll，select有啥区别

5、为什么跟lmkd的通信用socket，而不用binder或者其他通信方式

6、meminfo的free size是怎么计算的， zoneinfo的reserved page怎么算的

7、kill_one_process是通过什么实现的
函数start_wait_for_proc_kill 参数是将要kill 的进程的pid fd，将其添加到epoll 中进行监听。
并通过sys_pidfd_send_signal 发送SIGKILL 信号进行kill 操作。

8、swap回收的具体原理

9、psi的滑动平均是怎么计算的
这里的 avg 代表滑动平均，因为 PSI 反应的不是一个瞬时的概念，使用滑动平均可以让数据更平滑，这里使用的是 calc_load 函数进行求平滑，公式如下：
V_bt  = V_t    /（1 - β^t）


10、Some 这一行代表至少由一个任务被阻塞
Full 代表所有非 idle 任务同时被阻塞
后面紧跟的数字单位是秒，最后的数值是阻塞时间百分比


