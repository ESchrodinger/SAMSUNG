/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "lmkd"
#define PERFD_LIB  "libqti-perfd-client_system.so"
#define IOPD_LIB  "libqti-iopd-client_system.so"

#include <dlfcn.h>
#include <dirent.h>
#include <errno.h>
#include <inttypes.h>
#include <pwd.h>
#include <sched.h>
#include <signal.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <sys/cdefs.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/sysinfo.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#include <cutils/properties.h>
#include <cutils/sockets.h>
#include <liblmkd_utils.h>
#include <lmkd.h>
#include <log/log.h>
#include <log/log_event_list.h>
#include <log/log_time.h>
#include <private/android_filesystem_config.h>
#include <processgroup/processgroup.h>
#include <psi/psi.h>
#include <system/thread_defs.h>

#include "statslog.h"

/*
 * Define LMKD_TRACE_KILLS to record lmkd kills in kernel traces
 * to profile and correlate with OOM kills
 */
#ifdef LMKD_TRACE_KILLS

#define ATRACE_TAG ATRACE_TAG_ALWAYS
#include <cutils/trace.h>

#define TRACE_KILL_START(pid) ATRACE_INT(__FUNCTION__, pid);
#define TRACE_KILL_END()      ATRACE_INT(__FUNCTION__, 0);

#else /* LMKD_TRACE_KILLS */

#define TRACE_KILL_START(pid) ((void)(pid))
#define TRACE_KILL_END() ((void)0)

#endif /* LMKD_TRACE_KILLS */

#ifndef __unused
#define __unused __attribute__((__unused__))
#endif

#define MEMCG_SYSFS_PATH "/dev/memcg/"
#define MEMCG_MEMORY_USAGE "/dev/memcg/memory.usage_in_bytes"
#define MEMCG_MEMORYSW_USAGE "/dev/memcg/memory.memsw.usage_in_bytes"
#define ZONEINFO_PATH "/proc/zoneinfo"
#define MEMINFO_PATH "/proc/meminfo"
#define MEMINFO_EXTRA_PATH "/proc/meminfo_extra"
#define VMSTAT_PATH "/proc/vmstat"
#define PROC_STATUS_TGID_FIELD "Tgid:"
#define TRACE_MARKER_PATH "/sys/kernel/tracing/trace_marker"
#define PROC_STATUS_RSS_FIELD "VmRSS:"
#define PROC_STATUS_SWAP_FIELD "VmSwap:"
#define LINE_MAX 128
#define MAX_NR_ZONES 6

#define PERCEPTIBLE_APP_ADJ 200
#define VISIBLE_APP_ADJ 100

/* Android Logger event logtags (see event.logtags) */
#define KILLINFO_LOG_TAG 10195355

/* gid containing AID_SYSTEM required */
#define INKERNEL_MINFREE_PATH "/sys/module/lowmemorykiller/parameters/minfree"
#define INKERNEL_ADJ_PATH "/sys/module/lowmemorykiller/parameters/adj"
#define INKERNEL_LMKDCOUNT_PATH "/proc/lmkd_debug/lmkd_count"
#define INKERNEL_LMKDCRICOUNT_PATH "/proc/lmkd_debug/lmkd_cricount"
#define INKERNEL_MEMBOOST_NODE_PATH "/sys/kernel/mm/vmscan/mem_boost_mode"
#define INKERNEL_SYSRQTRIGGER_PATH "/proc/sysrq-trigger"

#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(*(x)))
#define EIGHT_MEGA (1 << 23)

#define TARGET_UPDATE_MIN_INTERVAL_MS 1000
#define THRASHING_RESET_INTERVAL_MS 1000

#define NS_PER_MS (NS_PER_SEC / MS_PER_SEC)
#define US_PER_MS (US_PER_SEC / MS_PER_SEC)

/* Defined as ProcessList.SYSTEM_ADJ in ProcessList.java */
#define SYSTEM_ADJ (-900)

#define STRINGIFY(x) STRINGIFY_INTERNAL(x)
#define STRINGIFY_INTERNAL(x) #x

/*
 * Read lmk property with persist.device_config.lmkd_native.<name> overriding ro.lmk.<name>
 * persist.device_config.lmkd_native.* properties are being set by experiments. If a new property
 * can be controlled by an experiment then use GET_LMK_PROPERTY instead of property_get_xxx and
 * add "on property" triggers in lmkd.rc to react to the experiment flag changes.
 */
#define GET_LMK_PROPERTY(type, name, def) \
    property_get_##type("persist.device_config.lmkd_native." name, \
        property_get_##type("ro.lmk." name, def))

/*
 * PSI monitor tracking window size.
 * PSI monitor generates events at most once per window,
 * therefore we poll memory state for the duration of
 * PSI_WINDOW_SIZE_MS after the event happens.
 */
#define PSI_WINDOW_SIZE_MS 1000
/* Polling period after PSI signal when pressure is high */
#define PSI_POLL_PERIOD_SHORT_MS 10
/* Polling period after PSI signal when pressure is low */
#define PSI_POLL_PERIOD_LONG_MS 100
/* PSI complete stall for super critical events */
#define PSI_SCRIT_COMPLETE_STALL_MS (75)

#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))

#define FAIL_REPORT_RLIMIT_MS 1000

#define SZ_4G (0x100000000ULL)

#define PSI_PROC_TRAVERSE_DELAY_MS 200
/*
 * System property defaults
 */
/* ro.lmk.swap_free_low_percentage property defaults */
#define DEF_LOW_SWAP 10
/* ro.lmk.thrashing_limit property defaults */
#define DEF_THRASHING_LOWRAM 30
#define DEF_THRASHING 100
/* ro.lmk.thrashing_limit_decay property defaults */
#define DEF_THRASHING_DECAY_LOWRAM 50
#define DEF_THRASHING_DECAY 10
/* ro.lmk.psi_partial_stall_ms property defaults */
#define DEF_PARTIAL_STALL_LOWRAM 200
#define DEF_PARTIAL_STALL 70
#define DEF_MOREPARTIAL_STALL 120
/* ro.lmk.psi_complete_stall_ms property defaults */
#define DEF_COMPLETE_STALL 700

#define KILL_SKIPPED -999
#define FREELIMIT_VAL_PRINT_CODE 9999
static long CAMERAMEM_LIMIT=128000;
static long REAL_CAMERAMEM_LIMIT;
static long saved_idle_camsize_init;
static long saved_diff_available_init;
static long saved_diff_iongmemvmalloc_init;
static long saved_idle_kreclaim_init;
static bool init_cam = false;
static pid_t prev_pid = -1;

#define LMKD_REINIT_PROP "lmkd.reinit"

#define PSI_OLD_LOW_THRESH_MS 0
#define PSI_OLD_MED_THRESH_MS 70
#define PSI_OLD_CRIT_THRESH_MS 120

static long multi_factor = 1;
#define PAGE_1_MB 256
#define PAGE_200_MB 51200
#define PSI_10_AVG 10
#define PSI_25_AVG 25

static inline int sys_pidfd_open(pid_t pid, unsigned int flags) {
    return syscall(__NR_pidfd_open, pid, flags);
}

static inline int sys_pidfd_send_signal(int pidfd, int sig, siginfo_t *info,
                                        unsigned int flags) {
    return syscall(__NR_pidfd_send_signal, pidfd, sig, info, flags);
}

/* default to old in-kernel interface if no memory pressure events */
static bool use_inkernel_interface = true;
static bool has_inkernel_module;

static int lmkd_count = 0;
static int lmkd_cricount = 0;

/* memory pressure levels */
enum vmpressure_level {
    VMPRESS_LEVEL_LOW = 0,
    VMPRESS_LEVEL_MEDIUM,
    VMPRESS_LEVEL_CRITICAL,
    VMPRESS_LEVEL_SUPER_CRITICAL,
    VMPRESS_LEVEL_COUNT
};
enum lmkd_parameter {
    LMK_LOW_ADJ = 0,
    LMK_MEDIUM_ADJ,
    LMK_CRITICAL_ADJ,
    LMK_DEBUG,
    LMK_CRITICAL_UPGRADE,
    LMK_UPGRADE_PRESSURE,
    LMK_DOWNGRADE_PRESSURE,
    LMK_KILL_HEAVIEST_TASK,
    LMK_KILL_TIMEOUT_MS,
    LMK_USE_MINFREE_LEVELS,
    LMK_ENABLE_USERSPACE_LMK,
    LMK_ENABLE_CMARBINFREE_SUB,
    LMK_ENABLE_UPGRADE_CRIADJ,
    LMK_FREELIMIT_ENABLE,
    LMK_FREELIMIT_VAL,
    LMK_PSI_LOW_TH,
    LMK_PSI_MEDIUM_TH,
    LMK_PSI_CRITICAL_TH,
    LMK_SET_SWAPTOTAL,
    LMK_SET_BG_KEEPING,
    LMK_PARAMETER_COUNT
};

static const char *level_name[] = {
    "low",
    "medium",
    "critical",
    "super critical",
};

struct {
    int64_t min_nr_free_pages; /* recorded but not used yet */
    int64_t max_nr_free_pages;
    int64_t low_adj_max_nr_free_pages;
    int64_t zoneinfo_min_pages;
} low_pressure_mem = { -1, -1, -1, -1};

struct psi_threshold {
    enum psi_stall_type stall_type;
    int threshold_ms;
};

static int level_oomadj[VMPRESS_LEVEL_COUNT];
static int mpevfd[VMPRESS_LEVEL_COUNT] = { -1, -1, -1, -1 };
static bool pidfd_supported;
static int last_kill_pid_or_fd = -1;
static struct timespec last_kill_tm;
static struct timespec saved_last_kill_tm;

/* lmkd configurable parameters */
static bool debug_process_killing;
static bool enable_pressure_upgrade;
static int64_t upgrade_pressure;
static int64_t downgrade_pressure;
static bool low_ram_device;
static bool kill_heaviest_task;
static unsigned long kill_timeout_ms;
static unsigned long kill_timeout_ms_ori;
static unsigned long kill_timeout_ms_med;
static int direct_reclaim_pressure = 45;
static int reclaim_scan_threshold = 1024;
static bool use_minfree_levels;
static bool force_use_old_strategy;
static bool per_app_memcg;
static bool enhance_batch_kill;
static bool enable_adaptive_lmk;
static bool enable_userspace_lmk;
static bool enable_watermark_check;
static bool enable_proc_get_script;
static int swap_free_low_percentage;
static int origin_swap_free_low_percentage;
static int psi_partial_stall_ms;
static int psi_complete_stall_ms;
static int psi_morepartial_stall_ms;
static int thrashing_limit_pct;
static int thrashing_limit_decay_pct;
static int thrashing_critical_pct;
static int swap_util_max;
static int64_t filecache_min_kb;
static bool use_psi_monitors = false;
static bool enable_preferred_apps =  false;
static bool enable_change_picked_adj = false;
static bool last_event_upgraded = false;
static int count_upgraded_event;
/* SystemSW2G SystemHealth, we do not use this code because we don't use perfd
static long pa_update_timeout_ms = 60000; // 1 min
*/
static int kpoll_fd;
/* PSI window related variables */
static int psi_window_size_ms = PSI_WINDOW_SIZE_MS;
static int psi_poll_period_scrit_ms = PSI_POLL_PERIOD_SHORT_MS;
static struct psi_threshold psi_thresholds[VMPRESS_LEVEL_COUNT] = {
    { PSI_SOME, PSI_OLD_LOW_THRESH_MS },    /* Default 70ms out of 1sec for partial stall */
    { PSI_SOME, PSI_OLD_MED_THRESH_MS },   /* Default 100ms out of 1sec for partial stall */
    { PSI_FULL, PSI_OLD_CRIT_THRESH_MS },    /* Default 70ms out of 1sec for complete stall */
    { PSI_FULL, PSI_SCRIT_COMPLETE_STALL_MS }, /* Default 80ms out of 1sec for complete stall */
};

static bool enable_cmarbinfree_sub;
static int lmkd_cached_proc_min;
static int total_memory_limit;
static int extra_under_memory_th_for_tuning;
static int extra_over_memory_th_for_tuning;
static int64_t extra_tuning_lmk_upgrade_pressure;
static int64_t extra_tuning_lmk_custom_sw_limit;
static int64_t extra_tuning_lmk_freelimit_val;
static int extra_tuning_min_cached_apps;
static bool enable_reentry_lmk;
static bool enable_upgrade_criadj;
static bool lmkd_freelimit_enable;
static bool use_lowmem_keep_except;
static int lowmem_keep_except_limit_val;
static bool psi_kill_keep_except;
static int64_t lmkd_freelimit_val;
static int64_t result_freelimit_val;
static int kill_keep_except;
static bool use_critical_kill_booster;
static bool use_camera_boost;
static bool use_camera_8k_boost;
static bool low_adj_kill_skip;
static int prev_memboost = 0;
static int prev_8k_memboost = 0;
static bool use_dr_kill_boost;
static bool use_light_dr_killbooster;
static bool dr_killboost=false;
static bool use_camera_kill_mode;
static bool use_camera_kill_mode_light;
static bool use_camera_kill_mode_light_v2;
static bool use_camera_kill_mode_noswaprss;
static int camera_killboost_time=1000;
static bool use_new_strategy;
static bool cameramode_killboost=false;
static int camera_idx=-1;
static int last_killed_adj=1001;
static pid_t cameraprovider_pid = -1;
static pid_t cameraserver_pid = -1;
static bool use_emergency_kill=false;
static bool is_movable_zone=false;
static int64_t low_cachemem_deadline_page_zone=12800;
static int64_t low_cachemem_deadline_page_common=76800;
static int64_t low_cachemem_deadline_page=89600;
static bool bora_policy_enable;
static bool use_bg_keeping_policy;
static bool origin_use_bg_keeping_policy;
static bool use_bg_keeping_policy_light;
static bool use_bg_keeping_adapt_tm;
static bool is_check_model_name=true;
static bool low_cachemem_deadline_page_zone_on_off;

static int launched_app_pid = -1;
static struct timespec last_launched_time;
static struct timespec last_boost_tm;
static struct timespec last_8k_boost_tm;

static struct timespec last_camera_open_tm;
static struct timespec last_camera_closed_tm;
static bool use_qc_feature=false;

static struct timespec boot_tm;
static int camera_kill_start_tm;
#define LAUNCHED_APP_KILL_DELAY_TIME 1000
#define LAUNCHED_CAMERA_MEMBOOST_TIME_INKERNEL 5000
#define LAUNCHED_CAMERA_MEMBOOST_TIME 1000
#define LAUNCHED_CAMERA_8K_MEMBOOST_TIME 3000
#define PROC_START_KILL_DELAY_TIME 1000
#define BOOT_EXCEPTION_RUNNING_TIME 600000

static android_log_context ctx;

enum polling_update {
    POLLING_DO_NOT_CHANGE,
    POLLING_START,
    POLLING_PAUSE,
    POLLING_RESUME,
};

/*
 * Data used for periodic polling for the memory state of the device.
 * Note that when system is not polling poll_handler is set to NULL,
 * when polling starts poll_handler gets set and is reset back to
 * NULL when polling stops.
 */
struct polling_params {
    struct event_handler_info* poll_handler;
    struct event_handler_info* paused_handler;
    struct timespec poll_start_tm;
    struct timespec last_poll_tm;
    int polling_interval_ms;
    enum polling_update update;
};

/* data required to handle events */
struct event_handler_info {
    int data;
    void (*handler)(int data, uint32_t events, struct polling_params *poll_params);
};

/* data required to handle socket events */
struct sock_event_handler_info {
    int sock;
    pid_t pid;
    uint32_t async_event_mask;
    struct event_handler_info handler_info;
};

/* max supported number of data connections (AMS, init, tests) */
#define MAX_DATA_CONN 3

/* socket event handler data */
static struct sock_event_handler_info ctrl_sock;
static struct sock_event_handler_info data_sock[MAX_DATA_CONN];

/* vmpressure event handler data */
static struct event_handler_info vmpressure_hinfo[VMPRESS_LEVEL_COUNT];

/*
 * 1 ctrl listen socket, 3 ctrl data socket, 4 memory pressure levels,
 * 1 lmk events + 1 fd to wait for process death
 */
#define MAX_EPOLL_EVENTS (1 + MAX_DATA_CONN + VMPRESS_LEVEL_COUNT + 1 + 1)
static int epollfd;
static int maxevents;

/* OOM score values used by both kernel and framework */
#define OOM_SCORE_ADJ_MIN       (-1000)
#define OOM_SCORE_ADJ_MAX       1000
#define OOM_SCORE_ADJ_FOREGROUND 0
#define PERCEPTIBLE_APP_ADJ 200
#define PERCEPTIBLE_LOW_APP_ADJ 250
#define OOM_SCORE_ADJ_BACKUPAPP       300
#define OOM_SCORE_ADJ_PREVIOUS       700
#define OOM_SCORE_ADJ_BSERVICE       800
#define OOM_SCORE_ADJ_PICKED       850
#define OOM_SCORE_ADJ_SEEDBED       860
#define OOM_SCORE_ADJ_CACHED_MIN       900
#define OOM_SCORE_ADJ_CACHED_MAX       999
#define PROCESS_STATE_SERVICE 10
#define PROCESS_STATE_CACHED_ACTIVITY 16
#define PROCESS_STATE_CACHED_ACTIVITY_CLIENT 17
#define PROCESS_STATE_CACHED_RECENT 18
#define PROCESS_STATE_CACHED_EMPTY 19
#define PROCESS_STATE_CACHED_EXCEPT 99
#define PROCESS_STATE_CACHED_SANDBOX 98
#define PROCESS_STATE_ACTIVE_LAUNCH 97
#define PROCESS_STATE_NAP_LAUNCH 96
#define PROCESS_STATE_PREVIOUS_APP 150
#define PROCESS_STATE_RECENT_ACTIVITY_LATEST 180
#define PROCESS_STATE_RECENT_ACTIVITY_MAXIMUM 199
#define PROCESS_STATE_VISIBLE_BROWSER 95
#define PROCESS_STATE_CAMERA_RELATED 94
#define PROCESS_STATE_BOOTING_EXCEPTION 93
static int lowmem_adj[MAX_TARGETS];
static int lowmem_minfree[MAX_TARGETS];
static int lowmem_targets_size;

/* Fields to parse in /proc/zoneinfo */
/* zoneinfo per-zone fields */
enum zoneinfo_zone_field {
    ZI_ZONE_NR_FREE_PAGES = 0,
    ZI_ZONE_MIN,
    ZI_ZONE_LOW,
    ZI_ZONE_HIGH,
    ZI_ZONE_PRESENT,
    ZI_ZONE_NR_FREE_CMA,
    ZI_ZONE_NR_FREE_RBIN,
    ZI_ZONE_NR_INACTIVE_FILE,
    ZI_ZONE_NR_ACTIVE_FILE,
    ZI_ZONE_FIELD_COUNT
};

static const char* const zoneinfo_zone_field_names[ZI_ZONE_FIELD_COUNT] = {
    "nr_free_pages",
    "min",
    "low",
    "high",
    "present",
    "nr_free_cma",
    "nr_free_rbin",
    "nr_zone_inactive_file",
    "nr_zone_active_file",
};

/* zoneinfo per-zone special fields */
enum zoneinfo_zone_spec_field {
    ZI_ZONE_SPEC_PROTECTION = 0,
    ZI_ZONE_SPEC_PAGESETS,
    ZI_ZONE_SPEC_FIELD_COUNT,
};

static const char* const zoneinfo_zone_spec_field_names[ZI_ZONE_SPEC_FIELD_COUNT] = {
    "protection:",
    "pagesets",
};

/* see __MAX_NR_ZONES definition in kernel mmzone.h */
#define MAX_NR_ZONES 6

union zoneinfo_zone_fields {
    struct {
        int64_t nr_free_pages;
        int64_t min;
        int64_t low;
        int64_t high;
        int64_t present;
        int64_t nr_free_cma;
        int64_t nr_free_rbin;
        int64_t nr_zone_inactive_file;
        int64_t nr_zone_active_file;
    } field;
    int64_t arr[ZI_ZONE_FIELD_COUNT];
};

struct zoneinfo_zone {
    union zoneinfo_zone_fields fields;
    int64_t protection[MAX_NR_ZONES];
    int64_t max_protection;
};

/* zoneinfo per-node fields */
enum zoneinfo_node_field {
    ZI_NODE_NR_INACTIVE_FILE = 0,
    ZI_NODE_NR_ACTIVE_FILE,
    ZI_NODE_FIELD_COUNT
};

static const char* const zoneinfo_node_field_names[ZI_NODE_FIELD_COUNT] = {
    "nr_inactive_file",
    "nr_active_file",
};

union zoneinfo_node_fields {
    struct {
        int64_t nr_inactive_file;
        int64_t nr_active_file;
    } field;
    int64_t arr[ZI_NODE_FIELD_COUNT];
};

struct zoneinfo_node {
    int id;
    int zone_count;
    int normal_idx;
    int movable_idx;
    struct zoneinfo_zone zones[MAX_NR_ZONES];
    union zoneinfo_node_fields fields;
};

/* for now two memory nodes is more than enough */
#define MAX_NR_NODES 2

struct zoneinfo {
    int node_count;
    struct zoneinfo_node nodes[MAX_NR_NODES];
    int64_t totalreserve_pages;
    int64_t total_inactive_file;
    int64_t total_active_file;
    int64_t total_nr_free_rbin;
    int64_t total_nr_free_cma;
    int64_t total_low;
    int64_t total_min;
};

/* Fields to parse in /proc/meminfo */
enum meminfo_field {
    MI_NR_TOTAL_PAGES = 0,
    MI_NR_FREE_PAGES,
    MI_AVAILABLE,
    MI_CACHED,
    MI_SWAP_CACHED,
    MI_BUFFERS,
    MI_SHMEM,
    MI_UNEVICTABLE,
    MI_TOTAL_RBIN,
    MI_ALLOC_RBIN,
    MI_CACHED_RBIN,
    MI_FREE_RBIN,
    MI_TOTAL_SWAP,
    MI_FREE_SWAP,
    MI_ACTIVE_ANON,
    MI_INACTIVE_ANON,
    MI_ACTIVE_FILE,
    MI_INACTIVE_FILE,
    MI_KRECLAIMABLE,
    MI_SRECLAIMABLE,
    MI_SUNRECLAIM,
    MI_KERNEL_STACK,
    MI_PAGE_TABLES,
    MI_ION_HELP,
    MI_ION_HELP_POOL,
    MI_HUGEPAGE_POOL,
    MI_CMA_FREE,
    MI_FIELD_COUNT
};

static const char* const meminfo_field_names[MI_FIELD_COUNT] = {
    "MemTotal:",
    "MemFree:",
    "MemAvailable:",
    "Cached:",
    "SwapCached:",
    "Buffers:",
    "Shmem:",
    "Unevictable:",
    "RbinTotal:",
    "RbinAlloced:",
    "RbinCached:",
    "RbinFree:",
    "SwapTotal:",
    "SwapFree:",
    "Active(anon):",
    "Inactive(anon):",
    "Active(file):",
    "Inactive(file):",
    "KReclaimable:",
    "SReclaimable:",
    "SUnreclaim:",
    "KernelStack:",
    "PageTables:",
    "ION_heap:",
    "ION_heap_pool:",
    "HugepagePool:",
    "CmaFree:",
};

union meminfo {
    struct {
        int64_t nr_total_pages;
        int64_t nr_free_pages;
        int64_t available;
        int64_t cached;
        int64_t swap_cached;
        int64_t buffers;
        int64_t shmem;
        int64_t unevictable;
        int64_t total_rbin;
        int64_t alloc_rbin;
        int64_t cached_rbin;
        int64_t free_rbin;
        int64_t total_swap;
        int64_t free_swap;
        int64_t active_anon;
        int64_t inactive_anon;
        int64_t active_file;
        int64_t inactive_file;
        int64_t kreclaimable;
        int64_t sreclaimable;
        int64_t sunreclaimable;
        int64_t kernel_stack;
        int64_t page_tables;
        int64_t ion_heap;
        int64_t ion_heap_pool;
        int64_t huge_page_pool;
        int64_t cma_free;
        /* fields below are calculated rather than read from the file */
        int64_t nr_file_pages;
    } field;
    int64_t arr[MI_FIELD_COUNT];
};

/* Fields to parse in /proc/meminfo_extra */
enum meminfo_extra_field {
    MI_EXTRA_SWAP_SIZE,
    MI_EXTRA_SYSTEM_HEAP,
    MI_EXTRA_SYSTEM_HEAP_POOL,
    MI_EXTRA_VMALLOC_API_SIZE,
    MI_EXTRA_KGSL_SHARED_MEM,
    MI_EXTRA_ION_VENDOR_SYSTEM_HEAP,
    MI_EXTRA_ION_ION_SYSTEM_HEAP,
    MI_EXTRA_SYSTEM,
    MI_EXTRA_SYSTEM_UNCACHED,
    MI_EXTRA_VMALLOCUSED,
    MI_EXTRA_FIELD_COUNT
};

static const char* const meminfo_extra_field_names[MI_EXTRA_FIELD_COUNT] = {
    "SystemHeap:",
    "SystemHeapPool:",
    "VmallocAPIsize:",
    "KgslSharedmem:",
    "ionsystem:",
    "ionion_system_heap:",
    "ioncamera_heap:",
    "system:",
    "system-uncached:",
    "VmallocUsed:",
};

union meminfo_extra {
    struct {
        int64_t system_heap;
        int64_t system_heap_pool;
        int64_t vmalloc_api_size;
        int64_t kgsl_shared_mem;
        int64_t ionsystem;
        int64_t ionion_system_heap;
        int64_t ioncamera_heap;
        int64_t system;
        int64_t system_uncached;
        int64_t vmallocused;
    } field;
    int64_t arr[MI_EXTRA_FIELD_COUNT];
};

/* Fields to parse in /proc/vmstat */
enum vmstat_field {
    VS_FREE_PAGES,
    VS_INACTIVE_FILE,
    VS_ACTIVE_FILE,
    VS_WORKINGSET_REFAULT,
    VS_WORKINGSET_REFAULT_FILE,
    VS_PGSCAN_KSWAPD,
    VS_PGSCAN_DIRECT,
    VS_PGSCAN_DIRECT_THROTTLE,
    VS_PGSKIP_FIRST_ZONE,
    VS_PGSKIP_DMA = VS_PGSKIP_FIRST_ZONE,
    VS_PGSKIP_NORMAL,
    VS_PGSKIP_HIGH,
    VS_PGSKIP_MOVABLE,
    VS_PGSKIP_LAST_ZONE = VS_PGSKIP_MOVABLE,
    VS_COMPACT_STALL,
    VS_FIELD_COUNT
};

#define PGSKIP_IDX(x) (x - VS_PGSKIP_FIRST_ZONE)

static const char* const vmstat_field_names[VS_FIELD_COUNT] = {
    "nr_free_pages",
    "nr_inactive_file",
    "nr_active_file",
    "workingset_refault",
    "workingset_refault_file",
    "pgscan_kswapd",
    "pgscan_direct",
    "pgscan_direct_throttle",
    "pgskip_dma32",
    "pgskip_normal",
    "pgskip_high",
    "pgskip_movable",
    "compact_stall",
};

union vmstat {
    struct {
        int64_t nr_free_pages;
        int64_t nr_inactive_file;
        int64_t nr_active_file;
        int64_t workingset_refault;
        int64_t workingset_refault_file;
        int64_t pgscan_kswapd;
        int64_t pgscan_direct;
        int64_t pgscan_direct_throttle;
        int64_t pgskip_dma;
        int64_t pgskip_normal;
        int64_t pgskip_high;
        int64_t pgskip_movable;
        int64_t compact_stall;
    } field;
    int64_t arr[VS_FIELD_COUNT];
};

enum field_match_result {
    NO_MATCH,
    PARSE_FAIL,
    PARSE_SUCCESS
};

struct watermark_info {
    char name[LINE_MAX];
    int free;
    int high;
    int cma;
    int present;
    int lowmem_reserve[MAX_NR_ZONES];
    int inactive_anon;
    int active_anon;
    int inactive_file;
    int active_file;
};

struct adjslot_list {
    struct adjslot_list *next;
    struct adjslot_list *prev;
};

struct proc {
    struct adjslot_list asl;
    int pid;
    int pidfd;
    uid_t uid;
    int oomadj;
    pid_t reg_pid; /* PID of the process that registered this record */
    int stateval;
    struct timespec proc_start_time;
    struct proc *pidhash_next;
};

struct reread_data {
    const char* const filename;
    int fd;
};

struct kill_info {
    enum kill_reasons kill_reason;
    const char *kill_desc;
    int thrashing;
    int max_thrashing;
};
/* SystemSW2G SystemHealth, we do not use following codes because we don't use perfd

typedef struct {
     char value[PROPERTY_VALUE_MAX];
} PropVal;


#define PREFERRED_OUT_LENGTH 12288
#define PAPP_OPCODE 10

char *preferred_apps;
void (*perf_ux_engine_trigger)(int, char *) = NULL;
*/

#define PIDHASH_SZ 1024
static struct proc *pidhash[PIDHASH_SZ];
#define pid_hashfn(x) ((((x) >> 8) ^ (x)) & (PIDHASH_SZ - 1))

#define ADJTOSLOT(adj) ((adj) + -OOM_SCORE_ADJ_MIN)
#define ADJTOSLOT_COUNT (ADJTOSLOT(OOM_SCORE_ADJ_MAX) + 1)
static struct adjslot_list procadjslot_list[ADJTOSLOT_COUNT];

#define MAX_DISTINCT_OOM_ADJ 32
#define KILLCNT_INVALID_IDX 0xFF
/*
 * Because killcnt array is sparse a two-level indirection is used
 * to keep the size small. killcnt_idx stores index of the element in
 * killcnt array. Index KILLCNT_INVALID_IDX indicates an unused slot.
 */
static uint8_t killcnt_idx[ADJTOSLOT_COUNT];
static uint16_t killcnt[MAX_DISTINCT_OOM_ADJ];
static int killcnt_free_idx = 0;
static uint32_t killcnt_total = 0;

static long cameraprocsize=0;
static long cameraproviderprocsize=0;
static long cameraserverprocsize=0;
static long saved_camera_size[101];
static long saved_ion_open_camera[101];
static long saved_ion_idle_camera[101];
static long saved_gmem_open_camera[101];
static long saved_gmem_idle_camera[101];
static long saved_vmallocmem_open_camera[101];
static long saved_vmallocmem_idle_camera[101];
static long fixed_memtotal=0;
static long saved_open_availmem[101];
static long saved_idle_availmem[101];
static long saved_close_kreclaim[101];
static long saved_idle_kreclaim[101];

/* Super critical event related variables. */
static union vmstat s_crit_base;
static bool s_crit_event = false;
static bool s_crit_event_upgraded = false;

/*
 * Initialize this as we decide the window size based on ram size for
 * lowram targets on old strategy.
 */
static long page_k = PAGE_SIZE / 1024;

/* Block QC Code
static void init_PreferredApps();
static void update_perf_props();
*/

static void update_props();
static bool init_monitors();
static void destroy_monitors();

static long proc_get_rss(int pid);
static char *proc_get_name(int pid, char *buf, size_t buf_size);
static bool read_proc_status(int pid, char *buf, size_t buf_sz);
static bool init_mp_psi(enum vmpressure_level level, bool use_new_strategy);
static void destroy_mp_psi(enum vmpressure_level level);

static int meminfo_extra_parse(union meminfo_extra *mi_extra);
static int meminfo_parse(union meminfo *mi);
static int zoneinfo_parse_common(struct zoneinfo *zi);
static long find_and_kill_process(int min_score_adj, struct kill_info *ki, union meminfo *mi,
                                  struct wakeup_info *wi, struct timespec *tm,
                                  enum vmpressure_level level);
static bool check_model_name(union meminfo *mi);
static bool check_model_trigger(union meminfo *mi);
enum wakeup_reason {
    Event,
    Polling
};

struct wakeup_info {
    struct timespec wakeup_tm;
    struct timespec prev_wakeup_tm;
    struct timespec last_event_tm;
    int wakeups_since_event;
    int skipped_wakeups;
};

static void record_wakeup_time(struct timespec *tm, enum wakeup_reason reason,
                               struct wakeup_info *wi);

#ifdef LMKD_CHIMERA
static bool chimera_enabled = false;
static bool chimera_check_enabled = false;
/* socket for connecting chimera */
int chimera_fd = -1;
static int chimera_swap_free_percentage_ths = 80;
struct timespec chimera_last_start_tm;
static int chimera_kill_interval = 5000;

#define CHIMERA_SWITCH_CHECK_DELAY 60000
#endif

static int clamp(int low, int high, int value) {
    return max(min(value, high), low);
}

static bool parse_int64(const char* str, int64_t* ret) {
    char* endptr;
    long long val = strtoll(str, &endptr, 10);
    if (str == endptr || val > INT64_MAX) {
        return false;
    }
    *ret = (int64_t)val;
    return true;
}

static int find_field(const char* name, const char* const field_names[], int field_count) {
    for (int i = 0; i < field_count; i++) {
        if (!strcmp(name, field_names[i])) {
            return i;
        }
    }
    return -1;
}

static enum field_match_result match_field(const char* cp, const char* ap,
                                   const char* const field_names[],
                                   int field_count, int64_t* field,
                                   int *field_idx) {
    int i = find_field(cp, field_names, field_count);
    if (i < 0) {
        return NO_MATCH;
    }
    *field_idx = i;
    return parse_int64(ap, field) ? PARSE_SUCCESS : PARSE_FAIL;
}

/*
 * Read file content from the beginning up to max_len bytes or EOF
 * whichever happens first.
 */
static ssize_t read_all(int fd, char *buf, size_t max_len)
{
    ssize_t ret = 0;
    off_t offset = 0;

    while (max_len > 0) {
        ssize_t r = TEMP_FAILURE_RETRY(pread(fd, buf, max_len, offset));
        if (r == 0) {
            break;
        }
        if (r == -1) {
            return -1;
        }
        ret += r;
        buf += r;
        offset += r;
        max_len -= r;
    }

    return ret;
}

/*
 * Read a new or already opened file from the beginning.
 * If the file has not been opened yet data->fd should be set to -1.
 * To be used with files which are read often and possibly during high
 * memory pressure to minimize file opening which by itself requires kernel
 * memory allocation and might result in a stall on memory stressed system.
 */
static char *reread_file(struct reread_data *data) {
    /* start with page-size buffer and increase if needed */
    static ssize_t buf_size = PAGE_SIZE;
    static char *new_buf, *buf = NULL;
    ssize_t size;

    if (data->fd == -1) {
        /* First-time buffer initialization */
        if (!buf && (buf = static_cast<char*>(malloc(buf_size))) == nullptr) {
            return NULL;
        }

        data->fd = TEMP_FAILURE_RETRY(open(data->filename, O_RDONLY | O_CLOEXEC));
        if (data->fd < 0) {
            ALOGE("%s open: %s", data->filename, strerror(errno));
            return NULL;
        }
    }

    while (true) {
        size = read_all(data->fd, buf, buf_size - 1);
        if (size < 0) {
            ALOGE("%s read: %s", data->filename, strerror(errno));
            close(data->fd);
            data->fd = -1;
            return NULL;
        }
        if (size < buf_size - 1) {
            break;
        }
        /*
         * Since we are reading /proc files we can't use fstat to find out
         * the real size of the file. Double the buffer size and keep retrying.
         */
        if ((new_buf = static_cast<char*>(realloc(buf, buf_size * 2))) == nullptr) {
            errno = ENOMEM;
            return NULL;
        }
        buf = new_buf;
        buf_size *= 2;
    }
    buf[size] = 0;

    return buf;
}

static bool claim_record(struct proc* procp, pid_t pid) {
    if (procp->reg_pid == pid) {
        /* Record already belongs to the registrant */
        return true;
    }
    if (procp->reg_pid == 0) {
        /* Old registrant is gone, claim the record */
        procp->reg_pid = pid;
        return true;
    }
    /* The record is owned by another registrant */
    return false;
}

static void remove_claims(pid_t pid) {
    int i;

    for (i = 0; i < PIDHASH_SZ; i++) {
        struct proc* procp = pidhash[i];
        while (procp) {
            if (procp->reg_pid == pid) {
                procp->reg_pid = 0;
            }
            procp = procp->pidhash_next;
        }
    }
}

static void ctrl_data_close(int dsock_idx) {
    struct epoll_event epev;

    ALOGI("closing lmkd data connection");
    if (epoll_ctl(epollfd, EPOLL_CTL_DEL, data_sock[dsock_idx].sock, &epev) == -1) {
        // Log a warning and keep going
        ALOGW("epoll_ctl for data connection socket failed; errno=%d", errno);
    }
    maxevents--;

    close(data_sock[dsock_idx].sock);
    data_sock[dsock_idx].sock = -1;

    /* Mark all records of the old registrant as unclaimed */
    remove_claims(data_sock[dsock_idx].pid);
}

static ssize_t ctrl_data_read(int dsock_idx, char* buf, size_t bufsz, struct ucred* sender_cred) {
    struct iovec iov = {buf, bufsz};
    char control[CMSG_SPACE(sizeof(struct ucred))];
    struct msghdr hdr = {
            NULL, 0, &iov, 1, control, sizeof(control), 0,
    };
    ssize_t ret;
    ret = TEMP_FAILURE_RETRY(recvmsg(data_sock[dsock_idx].sock, &hdr, 0));
    if (ret == -1) {
        ALOGE("control data socket read failed; %s", strerror(errno));
        return -1;
    }
    if (ret == 0) {
        ALOGE("Got EOF on control data socket");
        return -1;
    }

    struct ucred* cred = NULL;
    struct cmsghdr* cmsg = CMSG_FIRSTHDR(&hdr);
    while (cmsg != NULL) {
        if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_CREDENTIALS) {
            cred = (struct ucred*)CMSG_DATA(cmsg);
            break;
        }
        cmsg = CMSG_NXTHDR(&hdr, cmsg);
    }

    if (cred == NULL) {
        ALOGE("Failed to retrieve sender credentials");
        /* Close the connection */
        ctrl_data_close(dsock_idx);
        return -1;
    }

    memcpy(sender_cred, cred, sizeof(struct ucred));

    /* Store PID of the peer */
    data_sock[dsock_idx].pid = cred->pid;

    return ret;
}

static int ctrl_data_write(int dsock_idx, char* buf, size_t bufsz) {
    int ret = 0;

    ret = TEMP_FAILURE_RETRY(write(data_sock[dsock_idx].sock, buf, bufsz));

    if (ret == -1) {
        ALOGE("control data socket write failed; errno=%d", errno);
    } else if (ret == 0) {
        ALOGE("Got EOF on control data socket");
        ret = -1;
    }

    return ret;
}

/*
 * Write the pid/uid pair over the data socket, note: all active clients
 * will receive this unsolicited notification.
 */
static void ctrl_data_write_lmk_kill_occurred(pid_t pid, uid_t uid) {
    LMKD_CTRL_PACKET packet;
    size_t len = lmkd_pack_set_prockills(packet, pid, uid);

    for (int i = 0; i < MAX_DATA_CONN; i++) {
        if (data_sock[i].sock >= 0 && data_sock[i].async_event_mask & 1 << LMK_ASYNC_EVENT_KILL) {
            ctrl_data_write(i, (char*)packet, len);
        }
    }
}

/*
 * Write the kill_stat/memory_stat over the data socket to be propagated via AMS to statsd
 */
static void stats_write_lmk_kill_occurred(struct kill_stat *kill_st,
                                          struct memory_stat *mem_st) {
    LMK_KILL_OCCURRED_PACKET packet;
    const size_t len = lmkd_pack_set_kill_occurred(packet, kill_st, mem_st);
    if (len == 0) {
        return;
    }

    for (int i = 0; i < MAX_DATA_CONN; i++) {
        if (data_sock[i].sock >= 0 && data_sock[i].async_event_mask & 1 << LMK_ASYNC_EVENT_STAT) {
            ctrl_data_write(i, packet, len);
        }
    }

}

static void stats_write_lmk_kill_occurred_pid(int pid, struct kill_stat *kill_st,
                                              struct memory_stat *mem_st) {
    kill_st->taskname = stats_get_task_name(pid);
    if (kill_st->taskname != NULL) {
        stats_write_lmk_kill_occurred(kill_st, mem_st);
    }
}

/*
 * Write the state_changed over the data socket to be propagated via AMS to statsd
 */
static void stats_write_lmk_state_changed(enum lmk_state state) {
    LMKD_CTRL_PACKET packet_state_changed;
    const size_t len = lmkd_pack_set_state_changed(packet_state_changed, state);
    if (len == 0) {
        return;
    }
    for (int i = 0; i < MAX_DATA_CONN; i++) {
        if (data_sock[i].sock >= 0 && data_sock[i].async_event_mask & 1 << LMK_ASYNC_EVENT_STAT) {
            ctrl_data_write(i, (char*)packet_state_changed, len);
        }
    }
}

static void poll_kernel(int poll_fd) {
    if (poll_fd == -1) {
        // not waiting
        return;
    }

    while (1) {
        char rd_buf[256];
        int bytes_read = TEMP_FAILURE_RETRY(pread(poll_fd, (void*)rd_buf, sizeof(rd_buf), 0));
        if (bytes_read <= 0) break;
        rd_buf[bytes_read] = '\0';

        int64_t pid;
        int64_t uid;
        int64_t group_leader_pid;
        int64_t rss_in_pages;
        struct memory_stat mem_st = {};
        int16_t oom_score_adj;
        int16_t min_score_adj;
        int64_t starttime;
        char* taskname = 0;

        int fields_read =
                sscanf(rd_buf,
                       "%" SCNd64 " %" SCNd64 " %" SCNd64 " %" SCNd64 " %" SCNd64 " %" SCNd64
                       " %" SCNd16 " %" SCNd16 " %" SCNd64 "\n%m[^\n]",
                       &pid, &uid, &group_leader_pid, &mem_st.pgfault, &mem_st.pgmajfault,
                       &rss_in_pages, &oom_score_adj, &min_score_adj, &starttime, &taskname);

        /* only the death of the group leader process is logged */
        if (fields_read == 10 && group_leader_pid == pid) {
            ctrl_data_write_lmk_kill_occurred((pid_t)pid, (uid_t)uid);
            mem_st.process_start_time_ns = starttime * (NS_PER_SEC / sysconf(_SC_CLK_TCK));
            mem_st.rss_in_bytes = rss_in_pages * PAGE_SIZE;

            struct kill_stat kill_st = {
                .uid = static_cast<int32_t>(uid),
                .kill_reason = NONE,
                .oom_score = oom_score_adj,
                .min_oom_score = min_score_adj,
                .free_mem_kb = 0,
                .free_swap_kb = 0,
            };
            stats_write_lmk_kill_occurred_pid(pid, &kill_st, &mem_st);
        }

        free(taskname);
    }
}

static bool init_poll_kernel() {
    kpoll_fd = TEMP_FAILURE_RETRY(open("/proc/lowmemorykiller", O_RDONLY | O_NONBLOCK | O_CLOEXEC));

    if (kpoll_fd < 0) {
        ALOGE("kernel lmk event file could not be opened; errno=%d", errno);
        return false;
    }

    return true;
}

static struct proc *pid_lookup(int pid) {
    struct proc *procp;

    for (procp = pidhash[pid_hashfn(pid)]; procp && procp->pid != pid;
         procp = procp->pidhash_next)
            ;

    return procp;
}

static void adjslot_insert(struct adjslot_list *head, struct adjslot_list *new_element)
{
    struct adjslot_list *next = head->next;
    new_element->prev = head;
    new_element->next = next;
    next->prev = new_element;
    head->next = new_element;
}

static void adjslot_remove(struct adjslot_list *old)
{
    struct adjslot_list *prev = old->prev;
    struct adjslot_list *next = old->next;
    next->prev = prev;
    prev->next = next;
}

static struct adjslot_list *adjslot_tail(struct adjslot_list *head) {
    struct adjslot_list *asl = head->prev;

    return asl == head ? NULL : asl;
}

static void proc_slot(struct proc *procp) {
    int adjslot = ADJTOSLOT(procp->oomadj);

    adjslot_insert(&procadjslot_list[adjslot], &procp->asl);
}

static void proc_unslot(struct proc *procp) {
    adjslot_remove(&procp->asl);
}

static void proc_insert(struct proc *procp) {
    int hval = pid_hashfn(procp->pid);

    procp->pidhash_next = pidhash[hval];
    pidhash[hval] = procp;
    proc_slot(procp);
}

static int pid_remove(int pid) {
    int hval = pid_hashfn(pid);
    struct proc *procp;
    struct proc *prevp;

    for (procp = pidhash[hval], prevp = NULL; procp && procp->pid != pid;
         procp = procp->pidhash_next)
            prevp = procp;

    if (!procp)
        return -1;

    if (!prevp)
        pidhash[hval] = procp->pidhash_next;
    else
        prevp->pidhash_next = procp->pidhash_next;

    proc_unslot(procp);
    /*
     * Close pidfd here if we are not waiting for corresponding process to die,
     * in which case stop_wait_for_proc_kill() will close the pidfd later
     */
    if (procp->pidfd >= 0 && procp->pidfd != last_kill_pid_or_fd) {
        close(procp->pidfd);
    }
    free(procp);
    return 0;
}

/*
 * Write a string to a file.
 * Returns false if the file does not exist.
 */
static bool writefilestring(const char *path, const char *s,
                            bool err_if_missing) {
    int fd = open(path, O_WRONLY | O_CLOEXEC);
    ssize_t len = strlen(s);
    ssize_t ret;

    if (fd < 0) {
        if (err_if_missing) {
            ALOGE("Error opening %s; errno=%d", path, errno);
        }
        return false;
    }

    ret = TEMP_FAILURE_RETRY(write(fd, s, len));
    if (ret < 0) {
        ALOGE("Error writing %s; errno=%d", path, errno);
    } else if (ret < len) {
        ALOGE("Short write on %s; length=%zd", path, ret);
    }

    close(fd);
    return true;
}
static void writelmkdcount(){
    char lmkdcountval[20];

    snprintf(lmkdcountval, sizeof(lmkdcountval), "%d", lmkd_count);
    writefilestring(INKERNEL_LMKDCOUNT_PATH, lmkdcountval, true);
    snprintf(lmkdcountval, sizeof(lmkdcountval), "%d", lmkd_cricount);
    writefilestring(INKERNEL_LMKDCRICOUNT_PATH, lmkdcountval, true);
}
static void writesysrqtrigger(){
    char option[10];

    ALOGI("print processes meminfo in kernel log (sysrq-trigger)");
    snprintf(option, sizeof(option), "%s", "m");
    writefilestring(INKERNEL_SYSRQTRIGGER_PATH, option, true);
}
static inline long get_time_diff_ms(struct timespec *from,
                                    struct timespec *to) {
    return (to->tv_sec - from->tv_sec) * (long)MS_PER_SEC +
           (to->tv_nsec - from->tv_nsec) / (long)NS_PER_MS;
}
static void cmd_launchingproc_pid(LMKD_CTRL_PACKET packet) {
    struct lmk_procprio params;

    lmkd_pack_get_launchingproc_pid(packet, &params);

    launched_app_pid = params.pid;

    if (clock_gettime(CLOCK_MONOTONIC_COARSE, &last_launched_time) != 0) {
        ALOGE("Failed to get current time in  cmd_launchingproc_pid");
        return;
    }
    ALOGI("check proc pid launching app : %d", params.pid);
}

/* Reads /proc/pid/status into buf. */
static bool read_proc_status(int pid, char *buf, size_t buf_sz) {
    char path[PATH_MAX];
    int fd;
    ssize_t size;

    snprintf(path, PATH_MAX, "/proc/%d/status", pid);
    fd = open(path, O_RDONLY | O_CLOEXEC);
    if (fd < 0) {
        return false;
    }

    size = read_all(fd, buf, buf_sz - 1);
    close(fd);
    if (size < 0) {
        return false;
    }
    buf[size] = 0;
    return true;
}

/* Looks for tag in buf and parses the first integer */
static bool parse_status_tag(char *buf, const char *tag, int64_t *out) {
    char *pos = buf;
    while (true) {
        pos = strstr(pos, tag);
        /* Stop if tag not found or found at the line beginning */
        if (pos == NULL || pos == buf || pos[-1] == '\n') {
            break;
        }
        pos++;
    }

    if (pos == NULL) {
        return false;
    }

    pos += strlen(tag);
    while (*pos == ' ') ++pos;
    return parse_int64(pos, out);
}

static void proc_get_native_camera_pid(void)
{
    static DIR* d = NULL;
    struct dirent* de;

    pid_t pid;
    char *taskname;
    const char *cameraprovider_name = "vendor.samsung.hardware.camera.provider";
    const char *cameraserver_name = "cameraserver";
    char buf[LINE_MAX];
    int64_t tgid;

    if (!(d = opendir("/proc"))) {
        ALOGW("Failed to open %s; errno=%d", "/proc", errno);
        return;
    }

    while ((de = readdir(d))!=NULL) {
        if (sscanf(de->d_name, "%u", &pid) != 1)
            continue;

        /* Don't attempt to kill init */
        if (pid == 1)
            continue;

        taskname = proc_get_name(pid, buf, sizeof(buf));
        tgid = -1;

        if( taskname!=NULL && strstr(taskname, cameraprovider_name) ){
            if (read_proc_status(pid, buf, sizeof(buf))) {
                if ((parse_status_tag(buf, PROC_STATUS_TGID_FIELD, &tgid)) && tgid == pid) {
                    cameraprovider_pid = pid;
                }
            }
        } else if ( taskname!=NULL && strstr(taskname, cameraserver_name) ){
            if (read_proc_status(pid, buf, sizeof(buf))) {
                if ((parse_status_tag(buf, PROC_STATUS_TGID_FIELD, &tgid)) && tgid == pid) {
                    cameraserver_pid = pid;
                }
            }
        }
        if(cameraprovider_pid != -1 && cameraserver_pid != -1) break;
    }
    closedir(d);
    ALOGI("proc_get_native_camera_pid: %d, %d", cameraprovider_pid, cameraserver_pid);
}

static void cmd_camerakillboostmode_light(LMKD_CTRL_PACKET packet){
    struct lmk_camerainfo cameraInfo;
    lmkd_pack_get_camerakillboostmode(packet, &cameraInfo);

    if(cameraInfo.state == 0){
        ALOGI("check CAMERA OPEN, set cameramode_killboost true");
        cameramode_killboost = true;
        camera_idx = cameraInfo.appIndex;
    } else if (cameraInfo.state == 3) { // CAMERA CLOSE
        ALOGI("check CAMERA CLOSE, set cameramode_killboost false");
        cameramode_killboost = false;
    }
}
static void cmd_camerakillboostmode(LMKD_CTRL_PACKET packet) {
    union meminfo mi;
    struct zoneinfo zi;
    union meminfo_extra mi_extra;
    long pages_freed =0, sum_pages_freed =0;
    struct lmk_camerainfo cameraInfo;
    struct timespec curr_tm;
    /*long saved_ion = 0;
    long saved_gmem = 0;
    long saved_vmallocmem = 0;*/
    bool update_avail_mem = false;
    long cur_diff_available = 0;
    int64_t cur_ion = 0;
    long heap_pool = 0;
    static struct wakeup_info wi;
    struct kill_info ki = {
        .kill_reason = CAMERA_KILL_MODE,
        .kill_desc = NULL,
        .thrashing = 0,
        .max_thrashing = 0,
    };

    lmkd_pack_get_camerakillboostmode(packet, &cameraInfo);

    if(cameraInfo.state == 99){
        proc_get_native_camera_pid();
        return;
    }

    if (clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm) != 0) {
        ALOGE("Failed to get current time in cmd_camerakillboostmode");
    }

    if (camera_kill_start_tm > 0 && get_time_diff_ms(&boot_tm, &curr_tm) < camera_kill_start_tm) {
        cmd_camerakillboostmode_light(packet);
        return;
    }

    cameraproviderprocsize = proc_get_rss(cameraprovider_pid);
    cameraserverprocsize = proc_get_rss(cameraserver_pid);
    cameraprocsize = proc_get_rss(cameraInfo.pid) + cameraproviderprocsize + cameraserverprocsize;

    if (meminfo_parse(&mi) < 0 || zoneinfo_parse_common(&zi) < 0 || meminfo_extra_parse(&mi_extra) < 0 ) {
        ALOGE("Failed to get free memory!");
        return;
    }

    if(cameraInfo.appIndex==0 && prev_pid != cameraInfo.pid){
        if(cameraInfo.state == 0) {
            init_cam = true;
        }
    } else if(cameraInfo.appIndex==0 && prev_pid == cameraInfo.pid){
        if(cameraInfo.state == 0) {
            init_cam = false;
        }
    }

    if(mi.field.available >= 0.3 * (long)( fixed_memtotal / (4 * page_k) )) {
        update_avail_mem = true;
    }

    cur_ion = mi_extra.field.system_heap + mi_extra.field.ionion_system_heap;
    if(mi_extra.field.ionsystem > 0) cur_ion = cur_ion + mi_extra.field.ionsystem - mi_extra.field.ioncamera_heap;

    if(cameraInfo.appIndex > -1 && cameraInfo.appIndex < 100) {
        REAL_CAMERAMEM_LIMIT = saved_camera_size[cameraInfo.appIndex];
        if(init_cam && cameraInfo.appIndex == 0) {
            REAL_CAMERAMEM_LIMIT = saved_idle_camsize_init;
        }
    }
    if(REAL_CAMERAMEM_LIMIT == 0) {
        if (cameraInfo.appIndex == 0) {
            REAL_CAMERAMEM_LIMIT = CAMERAMEM_LIMIT;
        } else {
            REAL_CAMERAMEM_LIMIT = 128000;
        }
    }

    heap_pool = mi_extra.field.system_heap_pool;
    if(heap_pool==0) {
        if(init_cam && cameraInfo.appIndex == 0) {
            heap_pool = mi.field.kreclaimable - saved_idle_kreclaim_init;
        } else {
            heap_pool = mi.field.kreclaimable - saved_idle_kreclaim[cameraInfo.appIndex];
        }
        /*
        if(mi.field.kreclaimable < saved_idle_kreclaim[cameraInfo.appIndex]){
            heap_pool = 0;
        } else if(mi.field.kreclaimable < saved_close_kreclaim[cameraInfo.appIndex]){
            heap_pool = saved_close_kreclaim[cameraInfo.appIndex] - mi.field.kreclaimable;
        } else {
            heap_pool = saved_close_kreclaim[cameraInfo.appIndex] - saved_idle_kreclaim[cameraInfo.appIndex];
        }
        */
        if(heap_pool < 0) heap_pool = 0;
    }

    if(cameraInfo.state == 0 && get_time_diff_ms(&last_camera_closed_tm, &curr_tm) < 500) {
        ALOGI("check CAMERA OPEN but time within 500ms, skip to active");
        cameraInfo.state = 1;
        cameramode_killboost=true;
    }

    if(cameraInfo.state == 0){
        if(cameraInfo.appIndex > -1 && cameraInfo.appIndex < 100) {
            if(init_cam && cameraInfo.appIndex == 0) {
                cur_diff_available = saved_diff_available_init;
            } else {
                cur_diff_available = saved_open_availmem[cameraInfo.appIndex] - saved_idle_availmem[cameraInfo.appIndex];
            }
        } else {
            cur_diff_available = 0;
        }
        if(init_cam && cameraInfo.appIndex == 0) {
            REAL_CAMERAMEM_LIMIT = REAL_CAMERAMEM_LIMIT + saved_diff_iongmemvmalloc_init;
        } else {
            REAL_CAMERAMEM_LIMIT = REAL_CAMERAMEM_LIMIT + saved_ion_idle_camera[cameraInfo.appIndex] + saved_gmem_idle_camera[cameraInfo.appIndex] + saved_vmallocmem_idle_camera[cameraInfo.appIndex];
        }

        if(cur_diff_available > REAL_CAMERAMEM_LIMIT) REAL_CAMERAMEM_LIMIT = cur_diff_available;
        if(REAL_CAMERAMEM_LIMIT > CAMERAMEM_LIMIT) REAL_CAMERAMEM_LIMIT = CAMERAMEM_LIMIT;
    } else {
        /*
        if(cameraInfo.appIndex > -1 && cameraInfo.appIndex < 100) {
            saved_ion = saved_ion_open_camera[cameraInfo.appIndex] + saved_ion_idle_camera[cameraInfo.appIndex];
            saved_gmem = saved_gmem_open_camera[cameraInfo.appIndex] + saved_gmem_idle_camera[cameraInfo.appIndex];
            saved_vmallocmem = saved_vmallocmem_open_camera[cameraInfo.appIndex] + saved_vmallocmem_idle_camera[cameraInfo.appIndex];
        } else {
            saved_ion = 0;
            saved_gmem = 0;
            saved_vmallocmem = 0;
        }
        REAL_CAMERAMEM_LIMIT = REAL_CAMERAMEM_LIMIT + saved_ion + saved_gmem + saved_vmallocmem;
        */
    }

    ALOGI("check camkillboostmode : %d , ionheap: %" PRId64 ", pid : %d, index : %d , camprocall/provider/server size : (%ld, %ld, %ld), available : %" PRId64 ", heap_pool : %ld, kreclaimable : %" PRId64 ", init_cam : %d",
    cameraInfo.state, cur_ion, cameraInfo.pid, cameraInfo.appIndex , cameraprocsize, cameraproviderprocsize, cameraserverprocsize, mi.field.available, heap_pool, mi.field.kreclaimable, init_cam);

    if(cameraInfo.state == 0){ // CAMERA OPEN
        if(get_time_diff_ms(&last_camera_open_tm, &curr_tm) < 1500){
            ALOGI("cmd_camerakillboostmode is skipped!! time within 1500");
            return;
        }
        int64_t camera_other_free = mi.field.nr_free_pages - zi.totalreserve_pages;

        long beingkilledsize = 0;

        //int64_t camera_other_free = mi.field.nr_free_pages;
        camera_other_free = camera_other_free - mi.field.free_rbin;
        if(camera_other_free <=0) camera_other_free = 0;

        if(cameraInfo.appIndex > -1) {
            beingkilledsize = REAL_CAMERAMEM_LIMIT- camera_other_free - cameraprocsize - heap_pool;
            ALOGI("check CAMERA OPEN %ld, memlimit: %ld, other_free: %" PRId64 ", saved_ion_idle_camera: %ld, cameraprocsize: %ld, kgsl: %" PRId64 ", vmallocapi: %" PRId64 ", diff_available: %ld ", beingkilledsize, REAL_CAMERAMEM_LIMIT , camera_other_free, saved_ion_idle_camera[cameraInfo.appIndex], cameraprocsize, mi_extra.field.kgsl_shared_mem, mi_extra.field.vmalloc_api_size, cur_diff_available);
        } else {
            beingkilledsize = REAL_CAMERAMEM_LIMIT - camera_other_free - cameraprocsize - cur_ion - mi_extra.field.kgsl_shared_mem - mi_extra.field.vmalloc_api_size - heap_pool;
            ALOGI("check CAMERA OPEN %ld, memlimit: %ld, other_free: %" PRId64 ", saved_ion_idle_camera: %" PRId64 ", cameraprocsize: %ld, kgsl: %" PRId64 ", vmallocapi: %" PRId64 "", beingkilledsize,
                                                                REAL_CAMERAMEM_LIMIT , camera_other_free, cur_ion, cameraprocsize, mi_extra.field.kgsl_shared_mem, mi_extra.field.vmalloc_api_size);
        }

        if(cameraInfo.appIndex > -1 && cameraInfo.appIndex < 100){
            saved_ion_open_camera[cameraInfo.appIndex] = cur_ion;
            saved_gmem_open_camera[cameraInfo.appIndex] = mi_extra.field.kgsl_shared_mem;
            saved_vmallocmem_open_camera[cameraInfo.appIndex] = mi_extra.field.vmalloc_api_size;
            if(update_avail_mem){
                saved_open_availmem[cameraInfo.appIndex] = mi.field.available - (mi.field.total_rbin - mi.field.alloc_rbin);
            }
        }
        wi.wakeup_tm = curr_tm;
        record_wakeup_time(&curr_tm, Event, &wi);
        for (int sumcount=0; sumcount < 20; sumcount++) {
            if(sum_pages_freed >= beingkilledsize) break;
            pages_freed = find_and_kill_process(OOM_SCORE_ADJ_BSERVICE, &ki, &mi, &wi, &curr_tm, VMPRESS_LEVEL_MEDIUM);
            sum_pages_freed = sum_pages_freed + pages_freed;
        }
        /*
        use_critical_kill_booster = true;
        lmkd_freelimit_val = 11;
        downgrade_pressure = 80;
        upgrade_pressure = 80;
        */
        if (clock_gettime(CLOCK_MONOTONIC_COARSE, &last_camera_open_tm) != 0) {
            ALOGE("Failed to get current time in camerakillboostmode");
        }
        //save_pages_freed_flag = true;
        cameramode_killboost=true;
        camera_idx = cameraInfo.appIndex;
    } else if (cameraInfo.state == 1) { // state 2 => 1
        /*
        if(get_time_diff_ms(&last_camera_open_tm, &curr_tm) < 1500){
            ALOGI("camerakillboostmode is skipped!! time within 1500");
            return;
        }
        int64_t camera_other_free = mi.field.nr_free_pages - zi.totalreserve_pages;
        camera_other_free = camera_other_free - mi.field.free_rbin;
        if(camera_other_free <=0) camera_other_free = 0;

        long beingkilledsize = REAL_CAMERAMEM_LIMIT - camera_other_free - cameraprocsize - cur_ion - mi_extra.field.kgsl_shared_mem - mi_extra.field.vmalloc_api_size - heap_pool;
        ALOGI("check CAMERA ACTIVE %ld, cameramode: %s, memlimit: %ld, other_free: %" PRId64 ", heap: %" PRId64 ", saved_ion: %ld, cameraprocsize: %ld, kgsl: %" PRId64 ", vmallocapi: %" PRId64 "", beingkilledsize,
                                                                REAL_CAMERAMEM_LIMIT, camera_other_free, cur_ion, saved_ion, cameraprocsize, mi_extra.field.kgsl_shared_mem, mi_extra.field.vmalloc_api_size);

        for (int sumcount=0; sumcount < 10; sumcount++) {
            if(sum_pages_freed >= beingkilledsize) break;
            pages_freed = find_and_kill_process(OOM_SCORE_ADJ_BSERVICE, &ki, &mi, &wi, &curr_tm, VMPRESS_LEVEL_MEDIUM);
            sum_pages_freed = sum_pages_freed + pages_freed;
        }
        */
    } else if (cameraInfo.state == 2) { // state 1 => 2
        if(cameraInfo.appIndex> -1 && cameraInfo.appIndex < 100){
            saved_camera_size[cameraInfo.appIndex] = cameraprocsize;  // save camera size
            if(saved_camera_size[cameraInfo.appIndex] > CAMERAMEM_LIMIT) saved_camera_size[cameraInfo.appIndex] = CAMERAMEM_LIMIT;

            saved_ion_idle_camera[cameraInfo.appIndex] = cur_ion - saved_ion_open_camera[cameraInfo.appIndex];
            saved_gmem_idle_camera[cameraInfo.appIndex] = mi_extra.field.kgsl_shared_mem - saved_gmem_open_camera[cameraInfo.appIndex];
            saved_vmallocmem_idle_camera[cameraInfo.appIndex] = mi_extra.field.vmalloc_api_size - saved_vmallocmem_open_camera[cameraInfo.appIndex];
            saved_idle_kreclaim[cameraInfo.appIndex] = mi.field.kreclaimable;

            if(update_avail_mem){
                saved_idle_availmem[cameraInfo.appIndex] = mi.field.available - (mi.field.total_rbin - mi.field.alloc_rbin);
            }

            if(saved_ion_idle_camera[cameraInfo.appIndex] < 0) saved_ion_idle_camera[cameraInfo.appIndex] = 0;
            if(saved_gmem_idle_camera[cameraInfo.appIndex] < 0) saved_gmem_idle_camera[cameraInfo.appIndex] = 0;
            if(saved_vmallocmem_idle_camera[cameraInfo.appIndex] < 0) saved_vmallocmem_idle_camera[cameraInfo.appIndex] = 0;

            if(init_cam && cameraInfo.appIndex == 0) {
                saved_idle_camsize_init = saved_camera_size[cameraInfo.appIndex];
                saved_diff_available_init = saved_open_availmem[cameraInfo.appIndex] - saved_idle_availmem[cameraInfo.appIndex];
                saved_diff_iongmemvmalloc_init = saved_ion_idle_camera[cameraInfo.appIndex] + saved_gmem_idle_camera[cameraInfo.appIndex] + saved_vmallocmem_idle_camera[cameraInfo.appIndex];
                saved_idle_kreclaim_init = mi.field.kreclaimable;
            }
        }
        /*
        int64_t camera_other_free = mi.field.nr_free_pages - zi.totalreserve_pages;

        camera_other_free = camera_other_free - mi.field.free_rbin;
        if(camera_other_free <=0) camera_other_free = 0;

        long beingkilledsize = REAL_CAMERAMEM_LIMIT - camera_other_free - cameraprocsize - cur_ion - mi_extra.field.kgsl_shared_mem - mi_extra.field.vmalloc_api_size - heap_pool;
        ALOGI("check CAMERA IDLE %ld, cameramode: %s, memlimit: %ld, other_free: %" PRId64 ", heap: %" PRId64 ", saved_ion: %ld, cameraprocsize: %ld, kgsl: %" PRId64 ", vmallocapi: %" PRId64 "", beingkilledsize,
                                                                REAL_CAMERAMEM_LIMIT, camera_other_free, cur_ion, saved_ion, cameraprocsize, mi_extra.field.kgsl_shared_mem, mi_extra.field.vmalloc_api_size);
        //save_pages_freed_flag = false;
        */
    } else if (cameraInfo.state == 3) { // CAMERA CLOSE
        if(cameraInfo.appIndex> -1 && cameraInfo.appIndex < 100){
            saved_close_kreclaim[cameraInfo.appIndex] = mi.field.kreclaimable;
        }
        /*
        int64_t camera_other_free = mi.field.nr_free_pages - zi.totalreserve_pages;
        camera_other_free = camera_other_free - mi.field.free_rbin;
        if(camera_other_free <=0) camera_other_free = 0;

        long beingkilledsize = REAL_CAMERAMEM_LIMIT - camera_other_free - cameraprocsize - cur_ion - mi_extra.field.kgsl_shared_mem - mi_extra.field.vmalloc_api_size - heap_pool;
        ALOGI("check Camera CLOSED %ld, cameramode: %s, memlimit: %ld, other_free: %" PRId64 ", heap: %" PRId64 ", saved_ion: %ld, cameraprocsize: %ld, kgsl: %" PRId64 ", vmallocapi: %" PRId64 "", beingkilledsize,
                                                                REAL_CAMERAMEM_LIMIT, camera_other_free, cur_ion, saved_ion, cameraprocsize, mi_extra.field.kgsl_shared_mem, mi_extra.field.vmalloc_api_size);
        */
        cameramode_killboost=false;
        //save_pages_freed_flag = false;
        /*
        use_critical_kill_booster = false;
        lmkd_freelimit_val = 11;
        downgrade_pressure = 40;
        upgrade_pressure = 50;
        */
        if (clock_gettime(CLOCK_MONOTONIC_COARSE, &last_camera_closed_tm) != 0) {
            ALOGE("Failed to get current time in last_camera_closed_tm");
        }
    }

    if(cameraInfo.appIndex==0) prev_pid = cameraInfo.pid;
    ALOGI("check finished camerakillboostmode");
}

void set_lowmem_keep_except_limit_val(int64_t memtotal, int origin_limit_val) {
    const long mb_25_page = 6400;
    const long mb_37_5_page = 9600;
    const long mb_43_75_page = 11200;

    if (memtotal > 12 * 1024000) { // 16GB
        lowmem_keep_except_limit_val = 256000;  // 1000MB
        multi_factor = 8;
    } else if (memtotal > 8 * 1024000) { // 12GB
        lowmem_keep_except_limit_val = 204800;  // 800MB
        multi_factor = 8;
    } else if (memtotal > 6 * 1024000){ // 8GB
        lowmem_keep_except_limit_val = 128000;  // 500MB
        multi_factor = 8;
    } else if (memtotal > 4 * 1024000){ // 6GB
        lowmem_keep_except_limit_val = 102400;  // 400MB
        multi_factor = 6;
    } else if (memtotal > 3 * 1024000){ // 4GB
        lowmem_keep_except_limit_val = 76800;  // 300MB
        multi_factor = 3;
    } else if (memtotal > 2 * 1024000){ // 3GB
        lowmem_keep_except_limit_val = 51200;  // 200MB
        multi_factor = 2;
    } else if (memtotal > 1 * 1024000){ // 2GB
        lowmem_keep_except_limit_val = 25600;  // 100MB
        multi_factor = 2;
    } else { // 1GB
        lowmem_keep_except_limit_val = 25600;  // 100MB
        multi_factor = 1;
    }

    if(origin_limit_val!= 0) lowmem_keep_except_limit_val = origin_limit_val;

    if (memtotal > 4 * 1024000) { // over 4GB
        low_cachemem_deadline_page_zone = ((multi_factor * mb_25_page) > 0 ? (multi_factor * mb_25_page) : 12800);
        low_cachemem_deadline_page_common = ((multi_factor * mb_37_5_page) > 76800 ? (multi_factor * mb_37_5_page) : 76800);
        low_cachemem_deadline_page = ((multi_factor * mb_43_75_page) > 0 ? (multi_factor * mb_43_75_page) : 89600);
    } else {
        if(low_cachemem_deadline_page_zone_on_off){
            low_cachemem_deadline_page_zone = 12800;
        }else{
            low_cachemem_deadline_page_zone = -1;
        }
        low_cachemem_deadline_page_common = ((multi_factor * mb_37_5_page) > 0 ? (multi_factor * mb_37_5_page) : 76800);
        low_cachemem_deadline_page = -1;
    }
}

void set_camera_default_kill_size(int64_t memtotal) {
    if (memtotal > 8 * 1024000) { // 16GB and 12GB
        fixed_memtotal = 8 * 1024000;
    } else if (memtotal > 6 * 1024000){ // 8GB
        fixed_memtotal = 8 * 1024000;
    } else if (memtotal > 4 * 1024000){ // 6GB
        fixed_memtotal = 6 * 1024000;
    } else if (memtotal > 3 * 1024000){ // 4GB
        fixed_memtotal = 4 * 1024000;
    } else if (memtotal > 2 * 1024000){ // 3GB
        fixed_memtotal = 3 * 1024000;
    } else if (memtotal > 1 * 1024000){ // 2GB
        fixed_memtotal = 2 * 1024000;
    } else { // 1GB
        fixed_memtotal = 1 * 1024000;
    }

    CAMERAMEM_LIMIT = (fixed_memtotal / 5) / page_k;
}

static long proc_get_rss(int pid) {
    char path[PATH_MAX];
    char line[LINE_MAX];
    int fd;
    long rss = 0;
    long swaprss = 0;
    long resultrss = 0;
    long total;
    ssize_t ret;

    /* gid containing AID_READPROC required */
    snprintf(path, PATH_MAX, "/proc/%d/statlmkd", pid);
    fd = open(path, O_RDONLY | O_CLOEXEC);

    if (fd == -1) {
        /* gid containing AID_READPROC required */
        snprintf(path, PATH_MAX, "/proc/%d/statm", pid);
        fd = open(path, O_RDONLY | O_CLOEXEC);
        if (fd == -1)
            return -1;

        ret = read_all(fd, line, sizeof(line) - 1);
        if (ret < 0) {
            close(fd);
            return -1;
        }
        line[ret] = '\0';

        sscanf(line, "%ld %ld ", &total, &rss);
    } else {
        ret = read_all(fd, line, sizeof(line) - 1);
        if (ret < 0) {
            close(fd);
            return -1;
        }
        line[ret] = '\0';

        sscanf(line, "%ld %ld %ld", &total, &rss, &swaprss);
    }
    close(fd);

    resultrss = rss + swaprss;
    if(resultrss < 0) resultrss = 0;

    return resultrss;
}

static bool parse_vmswap(char *buf, long *data) {

	if(sscanf(buf, "VmSwap: %ld", data) == 1)
		return 1;

	return 0;
}

static long proc_get_swap(int pid) {
	char buf[PAGE_SIZE] = {0, };
	char path[PATH_MAX] = {0, };
	ssize_t ret;
	char *c, *save_ptr;
	int fd;
	long data;

	snprintf(path, PATH_MAX, "/proc/%d/status", pid);
	fd = open(path,  O_RDONLY | O_CLOEXEC);
	if (fd < 0)
		return 0;

	ret = read_all(fd, buf, sizeof(buf) - 1);
	if (ret < 0) {
		ALOGE("unable to read Vm status");
		data = 0;
		goto out;
	}

    buf[ret] = '\0';

	for(c = strtok_r(buf, "\n", &save_ptr); c;
		c = strtok_r(NULL, "\n", &save_ptr)) {
		if (parse_vmswap(c, &data))
			goto out;
	}

	ALOGE("Couldn't get Swap info. Is it kthread?");
	data = 0;
out:
	close(fd);
	/* Vmswap is in Kb. Convert to page size. */
	return (data >> 2);
}

static long proc_get_size(int pid)
{
	long size;

    if(use_qc_feature)
        return (size = proc_get_rss(pid)) ? size : proc_get_swap(pid);
    else
        return proc_get_rss(pid);
}

static long proc_get_vm(int pid) {
    char path[PATH_MAX];
    char line[LINE_MAX];
    int fd;
    long total;
    ssize_t ret;

    /* gid containing AID_READPROC required */
    snprintf(path, PATH_MAX, "/proc/%d/statm", pid);
    fd = open(path, O_RDONLY | O_CLOEXEC);
    if (fd == -1)
        return -1;

    ret = read_all(fd, line, sizeof(line) - 1);
    if (ret < 0) {
        close(fd);
        return -1;
    }

    sscanf(line, "%ld", &total);
    close(fd);
    return total;
}

static char *proc_get_name(int pid, char *buf, size_t buf_size) {
    char path[PATH_MAX];
    int fd;
    char *cp;
    ssize_t ret;

    /* gid containing AID_READPROC required */
    snprintf(path, PATH_MAX, "/proc/%d/cmdline", pid);
    fd = open(path, O_RDONLY | O_CLOEXEC);
    if (fd == -1) {
        return NULL;
    }
    ret = read_all(fd, buf, buf_size - 1);
    close(fd);
    if (ret < 0) {
        return NULL;
    }
    buf[ret] = '\0';

    cp = strchr(buf, ' ');
    if (cp) {
        *cp = '\0';
    }

    return buf;
}

static void cmd_procprio(LMKD_CTRL_PACKET packet, int field_count, struct ucred *cred) {
    struct proc *procp;
    char path[LINE_MAX];
    char val[20];
    int soft_limit_mult;
    struct lmk_procprio params;
    bool is_system_server;
    struct passwd *pwdrec;
    int64_t tgid;
    char buf[PAGE_SIZE];
    int prev_adj;

    if( field_count == 5 )
        lmkd_pack_get_procprio_stateval(packet, &params);
    else {
        lmkd_pack_get_procprio(packet, field_count, &params);
    }

    if (params.oomadj < OOM_SCORE_ADJ_MIN ||
        params.oomadj > OOM_SCORE_ADJ_MAX) {
        ALOGE("Invalid PROCPRIO oomadj argument %d", params.oomadj);
        return;
    }

    if (params.ptype < PROC_TYPE_FIRST || params.ptype >= PROC_TYPE_COUNT) {
        ALOGE("Invalid PROCPRIO process type argument %d", params.ptype);
        return;
    }

    /* Check if registered process is a thread group leader */
    if (read_proc_status(params.pid, buf, sizeof(buf))) {
        if (parse_status_tag(buf, PROC_STATUS_TGID_FIELD, &tgid) && tgid != params.pid) {
            ALOGE("Attempt to register a task that is not a thread group leader "
                  "(tid %d, tgid %" PRId64 ")", params.pid, tgid);
            return;
        }
    }

    /* gid containing AID_READPROC required */
    /* CAP_SYS_RESOURCE required */
    /* CAP_DAC_OVERRIDE required */
    snprintf(path, sizeof(path), "/proc/%d/oom_score_adj", params.pid);
    snprintf(val, sizeof(val), "%d", params.oomadj);
    if (!writefilestring(path, val, false)) {
        ALOGW("Failed to open %s; errno=%d: process %d might have been killed",
              path, errno, params.pid);
        /* If this file does not exist the process is dead. */
        return;
    }

    if (use_inkernel_interface) {
        stats_store_taskname(params.pid, proc_get_name(params.pid, path, sizeof(path)));
        return;
    }

    prev_adj = params.oomadj;
    if (params.stateval == PROCESS_STATE_PREVIOUS_APP) { // previous launched process
        params.oomadj = OOM_SCORE_ADJ_BACKUPAPP + (params.stateval - 100); // 350
    }

    if (params.stateval >= PROCESS_STATE_RECENT_ACTIVITY_LATEST && params.stateval <= PROCESS_STATE_RECENT_ACTIVITY_MAXIMUM) { // recent cached or picked process
        params.oomadj = OOM_SCORE_ADJ_BACKUPAPP + (params.stateval - 100); // 380 ~ 399
    }

    if (enable_change_picked_adj) {
        if (params.oomadj == OOM_SCORE_ADJ_PICKED && params.stateval == PROCESS_STATE_CACHED_EXCEPT) {
            params.oomadj = 400;
        }
    }

    if (bora_policy_enable) {
        if (params.oomadj >= OOM_SCORE_ADJ_BACKUPAPP && params.stateval == PROCESS_STATE_CACHED_EXCEPT) {
            params.oomadj = 360;
        }
    } else if (params.oomadj >= OOM_SCORE_ADJ_PICKED && params.stateval == PROCESS_STATE_CACHED_EXCEPT) { // pallowlist , amsprocess
        if(enable_upgrade_criadj) {
            params.oomadj = OOM_SCORE_ADJ_BSERVICE - 1;
        } else {
            if (params.oomadj >= OOM_SCORE_ADJ_CACHED_MIN) {
                params.oomadj = OOM_SCORE_ADJ_CACHED_MIN;
            }
        }
    }
    if (params.stateval == PROCESS_STATE_CACHED_ACTIVITY) {
        if (params.oomadj > OOM_SCORE_ADJ_CACHED_MIN && params.oomadj < OOM_SCORE_ADJ_CACHED_MAX && params.oomadj%2 == 1) {
            params.oomadj = params.oomadj - 5;
        }
    }

    /* lmkd should not change soft limits for services */
    if (params.ptype == PROC_TYPE_APP && per_app_memcg) {
        if (params.oomadj >= 900) {
            soft_limit_mult = 0;
        } else if (params.oomadj >= 800) {
            soft_limit_mult = 0;
        } else if (params.oomadj >= 700) {
            soft_limit_mult = 0;
        } else if (params.oomadj >= 600) {
            // Launcher should be perceptible, don't kill it.
            params.oomadj = 200;
            soft_limit_mult = 1;
        } else if (params.oomadj >= 500) {
            soft_limit_mult = 0;
        } else if (params.oomadj >= 400) {
            soft_limit_mult = 0;
        } else if (params.oomadj >= 300) {
            soft_limit_mult = 1;
        } else if (params.oomadj >= 200) {
            soft_limit_mult = 8;
        } else if (params.oomadj >= 100) {
            soft_limit_mult = 10;
        } else if (params.oomadj >=   0) {
            soft_limit_mult = 20;
        } else {
            // Persistent processes will have a large
            // soft limit 512MB.
            soft_limit_mult = 64;
        }

        snprintf(path, sizeof(path), MEMCG_SYSFS_PATH
                 "apps/uid_%d/pid_%d/memory.soft_limit_in_bytes",
                 params.uid, params.pid);
        snprintf(val, sizeof(val), "%d", soft_limit_mult * EIGHT_MEGA);

        /*
         * system_server process has no memcg under /dev/memcg/apps but should be
         * registered with lmkd. This is the best way so far to identify it.
         */
        is_system_server = (params.oomadj == SYSTEM_ADJ &&
                            (pwdrec = getpwnam("system")) != NULL &&
                            params.uid == pwdrec->pw_uid);
        writefilestring(path, val, !is_system_server);
    }

    procp = pid_lookup(params.pid);
    if (!procp) {
        int pidfd = -1;

        if (pidfd_supported) {
            pidfd = TEMP_FAILURE_RETRY(sys_pidfd_open(params.pid, 0));
            if (pidfd < 0) {
                ALOGE("pidfd_open for pid %d failed; errno=%d", params.pid, errno);
                return;
            }
        }

        procp = static_cast<struct proc*>(calloc(1, sizeof(struct proc)));
        if (!procp) {
            // Oh, the irony.  May need to rebuild our state.
            return;
        }

        procp->pid = params.pid;
        procp->pidfd = pidfd;
        procp->uid = params.uid;
        procp->reg_pid = cred->pid;
        procp->oomadj = params.oomadj;
        procp->stateval = params.stateval;
        if (clock_gettime(CLOCK_MONOTONIC_COARSE, &(procp->proc_start_time)) != 0) {
            ALOGE("Failed to get current time in procprio");
            (procp->proc_start_time).tv_nsec = -1;
            (procp->proc_start_time).tv_sec = -1;
        }

        proc_insert(procp);
    } else {
        if (!claim_record(procp, cred->pid)) {
            char buf[LINE_MAX];
            char *taskname = proc_get_name(cred->pid, buf, sizeof(buf));
            /* Only registrant of the record can remove it */
            ALOGE("%s (%d, %d) attempts to modify a process registered by another client",
                taskname ? taskname : "A process ", cred->uid, cred->pid);
            return;
        }
        proc_unslot(procp);
        procp->oomadj = params.oomadj;
        procp->stateval = params.stateval;
        proc_slot(procp);
    }
}

static void cmd_procremove(LMKD_CTRL_PACKET packet, struct ucred *cred) {
    struct lmk_procremove params;
    struct proc *procp;

    lmkd_pack_get_procremove(packet, &params);

    if (use_inkernel_interface) {
        /*
         * Perform an extra check before the pid is removed, after which it
         * will be impossible for poll_kernel to get the taskname. poll_kernel()
         * is potentially a long-running blocking function; however this method
         * handles AMS requests but does not block AMS.
         */
        poll_kernel(kpoll_fd);

        stats_remove_taskname(params.pid);
        return;
    }

    procp = pid_lookup(params.pid);
    if (!procp) {
        return;
    }

    if (!claim_record(procp, cred->pid)) {
        char buf[LINE_MAX];
        char *taskname = proc_get_name(cred->pid, buf, sizeof(buf));
        /* Only registrant of the record can remove it */
        ALOGE("%s (%d, %d) attempts to unregister a process registered by another client",
            taskname ? taskname : "A process ", cred->uid, cred->pid);
        return;
    }

    /*
     * WARNING: After pid_remove() procp is freed and can't be used!
     * Therefore placed at the end of the function.
     */
    pid_remove(params.pid);
}

static void cmd_procpurge(struct ucred *cred) {
    int i;
    struct proc *procp;
    struct proc *next;

    if (use_inkernel_interface) {
        stats_purge_tasknames();
        return;
    }

    for (i = 0; i < PIDHASH_SZ; i++) {
        procp = pidhash[i];
        while (procp) {
            next = procp->pidhash_next;
            /* Purge only records created by the requestor */
            if (claim_record(procp, cred->pid)) {
                pid_remove(procp->pid);
            }
            procp = next;
        }
    }
}

static void cmd_subscribe(int dsock_idx, LMKD_CTRL_PACKET packet) {
    struct lmk_subscribe params;

    lmkd_pack_get_subscribe(packet, &params);
    data_sock[dsock_idx].async_event_mask |= 1 << params.evt_type;
}

static void inc_killcnt(int oomadj) {
    int slot = ADJTOSLOT(oomadj);
    uint8_t idx = killcnt_idx[slot];

    if (idx == KILLCNT_INVALID_IDX) {
        /* index is not assigned for this oomadj */
        if (killcnt_free_idx < MAX_DISTINCT_OOM_ADJ) {
            killcnt_idx[slot] = killcnt_free_idx;
            killcnt[killcnt_free_idx] = 1;
            killcnt_free_idx++;
        } else {
            ALOGW("Number of distinct oomadj levels exceeds %d",
                MAX_DISTINCT_OOM_ADJ);
        }
    } else {
        /*
         * wraparound is highly unlikely and is detectable using total
         * counter because it has to be equal to the sum of all counters
         */
        killcnt[idx]++;
    }
    /* increment total kill counter */
    killcnt_total++;
}

static int get_killcnt(int min_oomadj, int max_oomadj) {
    int slot;
    int count = 0;

    // return result_freelimit_val for debug
    if (min_oomadj==FREELIMIT_VAL_PRINT_CODE && max_oomadj==FREELIMIT_VAL_PRINT_CODE){
        return result_freelimit_val;
    }

    if (min_oomadj > max_oomadj)
        return 0;

    /* special case to get total kill count */
    if (min_oomadj > OOM_SCORE_ADJ_MAX)
        return killcnt_total;

    while (min_oomadj <= max_oomadj &&
           (slot = ADJTOSLOT(min_oomadj)) < ADJTOSLOT_COUNT) {
        uint8_t idx = killcnt_idx[slot];
        if (idx != KILLCNT_INVALID_IDX) {
            count += killcnt[idx];
        }
        min_oomadj++;
    }

    return count;
}

static int cmd_getkillcnt(LMKD_CTRL_PACKET packet) {
    struct lmk_getkillcnt params;

    if (use_inkernel_interface) {
        /* kernel driver does not expose this information */
        return 0;
    }

    lmkd_pack_get_getkillcnt(packet, &params);

    return get_killcnt(params.min_oomadj, params.max_oomadj);
}

static void cmd_target(int ntargets, LMKD_CTRL_PACKET packet) {
    int i;
    struct lmk_target target;
    char minfree_str[PROPERTY_VALUE_MAX];
    char *pstr = minfree_str;
    char *pend = minfree_str + sizeof(minfree_str);
    static struct timespec last_req_tm;
    struct timespec curr_tm;

    if (ntargets < 1 || ntargets > (int)ARRAY_SIZE(lowmem_adj))
        return;

    /*
     * Ratelimit minfree updates to once per TARGET_UPDATE_MIN_INTERVAL_MS
     * to prevent DoS attacks
     */
    if (clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm) != 0) {
        ALOGE("Failed to get current time");
        return;
    }

    if (get_time_diff_ms(&last_req_tm, &curr_tm) <
        TARGET_UPDATE_MIN_INTERVAL_MS) {
        ALOGE("Ignoring frequent updated to lmkd limits");
        return;
    }

    last_req_tm = curr_tm;

    for (i = 0; i < ntargets; i++) {
        lmkd_pack_get_target(packet, i, &target);
        lowmem_minfree[i] = target.minfree;
        lowmem_adj[i] = target.oom_adj_score;

        pstr += snprintf(pstr, pend - pstr, "%d:%d,", target.minfree,
            target.oom_adj_score);
        if (pstr >= pend) {
            /* if no more space in the buffer then terminate the loop */
            pstr = pend;
            break;
        }
    }

    lowmem_targets_size = ntargets;

    /* Override the last extra comma */
    pstr[-1] = '\0';
    property_set("sys.lmk.minfree_levels", minfree_str);

    if (has_inkernel_module) {
        char minfreestr[128];
        char killpriostr[128];

        minfreestr[0] = '\0';
        killpriostr[0] = '\0';

        for (i = 0; i < lowmem_targets_size; i++) {
            char val[40];

            if (i) {
                strlcat(minfreestr, ",", sizeof(minfreestr));
                strlcat(killpriostr, ",", sizeof(killpriostr));
            }

            if(enable_userspace_lmk){
                snprintf(val, sizeof(val), "%d", 0);
                strlcat(minfreestr, val, sizeof(minfreestr));
                snprintf(val, sizeof(val), "%d", 0);
                strlcat(killpriostr, val, sizeof(killpriostr));
            } else {
                snprintf(val, sizeof(val), "%d", use_inkernel_interface ? lowmem_minfree[i] : 0);
                strlcat(minfreestr, val, sizeof(minfreestr));
                snprintf(val, sizeof(val), "%d", use_inkernel_interface ? lowmem_adj[i] : 0);
                strlcat(killpriostr, val, sizeof(killpriostr));
            }
        }

        writefilestring(INKERNEL_MINFREE_PATH, minfreestr, true);
        writefilestring(INKERNEL_ADJ_PATH, killpriostr, true);
    }
}

static void cmd_setparameter(LMKD_CTRL_PACKET packet) {
    struct lmk_setparameter params;
    lmkd_pack_get_setparameter(packet, &params);

    switch(params.index){
        case LMK_LOW_ADJ:
            ALOGI("lmkd setparameter : ro.slmk.low (%d -> %d)", level_oomadj[VMPRESS_LEVEL_LOW] , params.value);
            level_oomadj[VMPRESS_LEVEL_LOW] = params.value;
            break;
        case LMK_MEDIUM_ADJ:
            ALOGI("lmkd setparameter : ro.slmk.medium (%d -> %d)", level_oomadj[VMPRESS_LEVEL_MEDIUM] , params.value);
            level_oomadj[VMPRESS_LEVEL_MEDIUM] = params.value;
            break;
        case LMK_CRITICAL_ADJ:
            ALOGI("lmkd setparameter : ro.slmk.critical (%d -> %d)", level_oomadj[VMPRESS_LEVEL_CRITICAL] , params.value);
            level_oomadj[VMPRESS_LEVEL_CRITICAL] = params.value;
            break;
        case LMK_DEBUG:
            ALOGI("lmkd setparameter : ro.slmk.debug (%d -> %d)", debug_process_killing , (params.value != 0) );
            debug_process_killing = (params.value != 0);
            break;
        case LMK_CRITICAL_UPGRADE:
            ALOGI("lmkd setparameter : ro.slmk.critical_upgrade (%d -> %d)", enable_pressure_upgrade , (params.value != 0) );
            enable_pressure_upgrade = (params.value != 0);
            break;
        case LMK_UPGRADE_PRESSURE:
            ALOGI("lmkd setparameter : ro.slmk.upgrade_pressure (%" PRId64 " -> %" PRId64 ")", upgrade_pressure , (int64_t)(params.value) );
            upgrade_pressure = (int64_t)(params.value);
            break;
        case LMK_DOWNGRADE_PRESSURE:
            ALOGI("lmkd setparameter : ro.slmk.downgrade_pressure (%" PRId64 " -> %" PRId64 ")", downgrade_pressure , (int64_t)(params.value) );
            downgrade_pressure = (int64_t)(params.value);
            break;
        case LMK_KILL_HEAVIEST_TASK:
            ALOGI("lmkd setparameter : ro.slmk.kill_heaviest_task (%d -> %d)", kill_heaviest_task , (params.value != 0) );
            kill_heaviest_task = (params.value != 0);
            break;
        case LMK_KILL_TIMEOUT_MS:
            ALOGI("lmkd setparameter : ro.slmk.kill_timeout_ms (%lu -> %lu)", kill_timeout_ms , (unsigned long)(params.value) );
            kill_timeout_ms = (unsigned long)(params.value);
            break;
        case LMK_USE_MINFREE_LEVELS:
            ALOGI("lmkd setparameter : ro.slmk.use_minfree_levels (%d -> %d)", use_minfree_levels , (params.value != 0) );
            use_minfree_levels = (params.value != 0);
            break;
        case LMK_ENABLE_USERSPACE_LMK:
            ALOGI("lmkd setparameter : ro.slmk.enable_userspace_lmk (%d -> %d)", enable_userspace_lmk , (params.value != 0) );
            enable_userspace_lmk = (params.value != 0);
            break;
        case LMK_ENABLE_CMARBINFREE_SUB:
            ALOGI("lmkd setparameter : ro.slmk.enable_cmarbinfree_sub (%d -> %d)", enable_cmarbinfree_sub , (params.value != 0) );
            enable_cmarbinfree_sub = (params.value != 0);
            break;
        case LMK_ENABLE_UPGRADE_CRIADJ:
            ALOGI("lmkd setparameter : ro.slmk.enable_upgrade_criadj (%d -> %d)", enable_upgrade_criadj , (params.value != 0) );
            enable_upgrade_criadj = (params.value != 0);
            break;
        case LMK_FREELIMIT_ENABLE:
            ALOGI("lmkd setparameter : ro.slmk.freelimit_enable (%d -> %d)", lmkd_freelimit_enable , (params.value != 0) );
            lmkd_freelimit_enable = (params.value != 0);
            break;
        case LMK_FREELIMIT_VAL:
            ALOGI("lmkd setparameter : ro.slmk.freelimit_val (%" PRId64 " -> %" PRId64 ")", lmkd_freelimit_val , (int64_t)(params.value) );
            lmkd_freelimit_val = (int64_t)(params.value);
            break;
        case LMK_PSI_LOW_TH:
            ALOGI("lmkd setparameter : ro.slmk.psi_low (%d -> %d)", psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms , params.value);
            psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = params.value;
            break;
        case LMK_PSI_MEDIUM_TH:
            ALOGI("lmkd setparameter : ro.slmk.psi_medium (%d -> %d)", psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms , params.value);
            psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms = params.value;
            destroy_mp_psi(VMPRESS_LEVEL_MEDIUM);
            if(init_mp_psi(VMPRESS_LEVEL_MEDIUM, use_new_strategy)){
                maxevents--;
            }
            break;
        case LMK_PSI_CRITICAL_TH:
            ALOGI("lmkd setparameter : ro.slmk.psi_critical (%d -> %d)", psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms , params.value);
            psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms = params.value;
            destroy_mp_psi(VMPRESS_LEVEL_CRITICAL);
            if(init_mp_psi(VMPRESS_LEVEL_CRITICAL, use_new_strategy)){
                maxevents--;
            }
            break;
        case LMK_SET_SWAPTOTAL:
            is_check_model_name = false;
            break;
        case LMK_SET_BG_KEEPING:
            use_bg_keeping_policy = (params.value != 0);
            ALOGI("lmkd setparameter : use_bg_keeping_policy : %d", use_bg_keeping_policy);
            break;
        default:
            break;
    }
}

static void ctrl_command_handler(int dsock_idx) {
    LMKD_CTRL_PACKET packet;
    struct ucred cred;
    int len;
    enum lmk_cmd cmd;
    int nargs;
    int targets;
    int kill_cnt;
    int result;

    len = ctrl_data_read(dsock_idx, (char *)packet, CTRL_PACKET_MAX_SIZE, &cred);
    if (len <= 0)
        return;

    if (len < (int)sizeof(int)) {
        ALOGE("Wrong control socket read length len=%d", len);
        return;
    }

    cmd = lmkd_pack_get_cmd(packet);
    nargs = len / sizeof(int) - 1;
    if (nargs < 0)
        goto wronglen;

    switch(cmd) {
    case LMK_TARGET:
        targets = nargs / 2;
        if (nargs & 0x1 || targets > (int)ARRAY_SIZE(lowmem_adj))
            goto wronglen;
        cmd_target(targets, packet);
        break;
    case LMK_PROCPRIO:
        /* process type field is optional for backward compatibility */
        if (nargs < 3 || nargs > 4)
            goto wronglen;
        cmd_procprio(packet, nargs, &cred);
        break;
    case LMK_PROCREMOVE:
        if (nargs != 1)
            goto wronglen;
        cmd_procremove(packet, &cred);
        break;
    case LMK_PROCPURGE:
        if (nargs != 0)
            goto wronglen;
        cmd_procpurge(&cred);
        break;
    case LMK_GETKILLCNT:
        if (nargs != 2)
            goto wronglen;
        kill_cnt = cmd_getkillcnt(packet);
        len = lmkd_pack_set_getkillcnt_repl(packet, kill_cnt);
        if (ctrl_data_write(dsock_idx, (char *)packet, len) != len)
            return;
        break;
    case LMK_SUBSCRIBE:
        if (nargs != 1)
            goto wronglen;
        cmd_subscribe(dsock_idx, packet);
        break;
    case LMK_PROCKILL:
        /* This command code is NOT expected at all */
        ALOGE("Received unexpected command code %d", cmd);
        break;
    case LMK_SETPARAMETER:
        if (nargs != 2)
            goto wronglen;
        cmd_setparameter(packet);
        break;
    case LMK_PROCPRIOSTT:
        if (nargs != 4)
            goto wronglen;
        cmd_procprio(packet, nargs+1, &cred);
        break;
    case LMK_LAUNCHPID:
        if (nargs != 1)
            goto wronglen;
        cmd_launchingproc_pid(packet);
        break;
    case LMK_CAMERAKILLBOOST:
        if (nargs != 3)
            goto wronglen;
        if(use_camera_kill_mode_light_v2){
            cmd_camerakillboostmode_light(packet);
        } else {
            cmd_camerakillboostmode(packet);
        }
        break;
    case LMK_UPDATE_PROPS:
        if(nargs == 2){
            /* disable mediatek patch
            int val=packet[2];
            switch(packet[1]){
                case 0:
                    if(val > 0 && val <= 100) {
                        thrashing_limit_pct = val;
                        ALOGE("[socket]lmkd param update [thrashinglimit] val=%d", thrashing_limit_pct);
                    }
                    break;
                case 1:
                    if(val > 0 && val <= 100) {
                        swap_free_low_percentage = val;
                        ALOGE("[socket]lmkd param update [swaplow] val=%d", swap_free_low_percentage);
                    }
                    break;
                case 2:
                    if(val > 0 && val <= 1000) {
                        kill_timeout_ms = val;
                        ALOGE("[socket]lmkd param update [killtimeout] val=%d", (int)kill_timeout_ms);
                    }
                    break;
            }
            ALOGI("lmkd param updated");
            */
            result = 0;
            goto sendresult;
            return;
        }
        if (nargs != 0)
            goto wronglen;
        update_props();
        if (!use_inkernel_interface) {
            /* Reinitialize monitors to apply new settings */
            destroy_monitors();
            result = init_monitors() ? 0 : -1;
        } else {
            result = 0;
        }
sendresult:
        len = lmkd_pack_set_update_props_repl(packet, result);
        if (ctrl_data_write(dsock_idx, (char *)packet, len) != len) {
            ALOGE("Failed to report operation results");
        }
        if (!result) {
            ALOGI("Properties reinitilized");
        } else {
            /* New settings can't be supported, crash to be restarted */
            ALOGE("New configuration is not supported. Exiting...");
            exit(1);
        }
        break;
    default:
        ALOGE("Received unknown command code %d", cmd);
        return;
    }

    return;

wronglen:
    ALOGE("Wrong control socket read length cmd=%d len=%d", cmd, len);
}

static void ctrl_data_handler(int data, uint32_t events,
                              struct polling_params *poll_params __unused) {
    if (events & EPOLLIN) {
        ctrl_command_handler(data);
    }
}

static int get_free_dsock() {
    for (int i = 0; i < MAX_DATA_CONN; i++) {
        if (data_sock[i].sock < 0) {
            return i;
        }
    }
    return -1;
}

static void ctrl_connect_handler(int data __unused, uint32_t events __unused,
                                 struct polling_params *poll_params __unused) {
    struct epoll_event epev;
    int free_dscock_idx = get_free_dsock();

    if (free_dscock_idx < 0) {
        /*
         * Number of data connections exceeded max supported. This should not
         * happen but if it does we drop all existing connections and accept
         * the new one. This prevents inactive connections from monopolizing
         * data socket and if we drop ActivityManager connection it will
         * immediately reconnect.
         */
        for (int i = 0; i < MAX_DATA_CONN; i++) {
            ctrl_data_close(i);
        }
        free_dscock_idx = 0;
    }

    data_sock[free_dscock_idx].sock = accept(ctrl_sock.sock, NULL, NULL);
    if (data_sock[free_dscock_idx].sock < 0) {
        ALOGE("lmkd control socket accept failed; errno=%d", errno);
        return;
    }

    ALOGI("lmkd data connection established");
    /* use data to store data connection idx */
    data_sock[free_dscock_idx].handler_info.data = free_dscock_idx;
    data_sock[free_dscock_idx].handler_info.handler = ctrl_data_handler;
    data_sock[free_dscock_idx].async_event_mask = 0;
    epev.events = EPOLLIN;
    epev.data.ptr = (void *)&(data_sock[free_dscock_idx].handler_info);
    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, data_sock[free_dscock_idx].sock, &epev) == -1) {
        ALOGE("epoll_ctl for data connection socket failed; errno=%d", errno);
        ctrl_data_close(free_dscock_idx);
        return;
    }
    maxevents++;
}

#ifdef LMKD_CHIMERA
/*
 * Connect the chimera socket
 */
static int connect_chimera(void) {
    int fd = socket_local_client("chimera",
                  ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM);
    if(fd < 0) {
        ALOGE("Fail to connect to chimera socket. return code: %d, err: %s", fd, strerror(errno));
        return -1;
    }
    return fd;
}

/* Entry to trigger chimera */
static void trigger_chimera(int min_score_adj, int minfree,
        int level, int64_t mem_pressure) {
    if (chimera_fd < 0) {
        chimera_fd = connect_chimera();
        if (chimera_fd < 0) {
            return;
        }
    }

    int pressure = (int)mem_pressure;
    char buf[256];
    int ret = snprintf(buf, sizeof(buf), "%d:%d:%d:%d\r\n", min_score_adj,
            minfree, level, pressure);
    if (ret >= (ssize_t)sizeof(buf)) {
        ALOGE ("trigger chimera Error, out of size");
    }

    ssize_t written;
    written = write(chimera_fd, buf, strlen(buf) + 1);
    if (written < 0) {
        ALOGE ("trigger chimera written:%zu", written);
        close(chimera_fd);
        chimera_fd = -1;
        return;
    }
}

static void check_chimera_trigger_condition(union meminfo *mi, struct timespec *curr,
        int level, int minfree, int mem_pressure) {
    if (!chimera_check_enabled && !chimera_enabled) {
        if (get_time_diff_ms(&chimera_last_start_tm, curr) >= CHIMERA_SWITCH_CHECK_DELAY) {
            chimera_enabled = property_get_bool("persist.config.chimera.enable", false);
            ALOGD("refetch chimera enabled flag :[%d] from property ", chimera_enabled);
            chimera_check_enabled = true;
        }
    }

    if (chimera_enabled && (mi->field.free_swap <=
        mi->field.total_swap * chimera_swap_free_percentage_ths / 100)) {
        if (get_time_diff_ms(&chimera_last_start_tm, curr) >= chimera_kill_interval) {
            chimera_last_start_tm = *curr;
            trigger_chimera(level_oomadj[level], minfree, level, mem_pressure);
        }
    }
}
#endif


/*
 * /proc/zoneinfo parsing routines
 * Expected file format is:
 *
 *   Node <node_id>, zone   <zone_name>
 *   (
 *    per-node stats
 *       (<per-node field name> <value>)+
 *   )?
 *   (pages free     <value>
 *       (<per-zone field name> <value>)+
 *    pagesets
 *       (<unused fields>)*
 *   )+
 *   ...
 */
static void zoneinfo_parse_protection(char *buf, struct zoneinfo_zone *zone) {
    int zone_idx;
    int64_t max = 0;
    char *save_ptr;

    for (buf = strtok_r(buf, "(), ", &save_ptr), zone_idx = 0;
         buf && zone_idx < MAX_NR_ZONES;
         buf = strtok_r(NULL, "), ", &save_ptr), zone_idx++) {
        long long zoneval = strtoll(buf, &buf, 0);
        if (zoneval > max) {
            max = (zoneval > INT64_MAX) ? INT64_MAX : zoneval;
        }
        zone->protection[zone_idx] = zoneval;
    }
    zone->max_protection = max;
}

static int zoneinfo_parse_zone_and_node(char **buf, struct zoneinfo_zone *zone, struct zoneinfo_node *node) {
    int fields_to_match = ZI_NODE_FIELD_COUNT;
    bool do_zone_match_flag = true;

    for (char *line = strtok_r(NULL, "\n", buf); line;
         line = strtok_r(NULL, "\n", buf)) {
        char *cp;
        char *ap;
        char *save_ptr;
        int64_t val;
        int field_idx;
        int field_idx2;
        enum field_match_result match_res;

        cp = strtok_r(line, " ", &save_ptr);

        if (!cp) {
            return false;
        }

        field_idx = find_field(cp, zoneinfo_zone_spec_field_names, ZI_ZONE_SPEC_FIELD_COUNT);
        if (field_idx >= 0) {
            /* special field */
            if (field_idx == ZI_ZONE_SPEC_PAGESETS) {
                /* no mode fields we are interested in */
                return true;
            }

            /* protection field */
            ap = strtok_r(NULL, ")", &save_ptr);
            if (ap) {
                zoneinfo_parse_protection(ap, zone);
            }
            continue;
        }

        ap = strtok_r(NULL, " ", &save_ptr);

        if (!ap) {
            continue;
        }

        match_res = match_field(cp, ap, zoneinfo_zone_field_names, ZI_ZONE_FIELD_COUNT,
            &val, &field_idx);

        if (match_res == PARSE_FAIL) {
            return false;
        }
        if (match_res == PARSE_SUCCESS) {
            zone->fields.arr[field_idx] = val;
        }
        if (field_idx == ZI_ZONE_PRESENT && val == 0) {
            /* zone is not populated, stop parsing it */
            return true;
        }

        if (do_zone_match_flag && match_res == NO_MATCH) {
            match_res = match_field(cp, ap, zoneinfo_node_field_names, ZI_NODE_FIELD_COUNT,
                &val, &field_idx2);
            if (match_res == PARSE_FAIL) {
                return false;
            }
            if (match_res == PARSE_SUCCESS) {
                node->fields.arr[field_idx2] = val;
                fields_to_match--;
                if (!fields_to_match) {
                    do_zone_match_flag = false;
                }
            }
        }
    }
    return false;
}

static int zoneinfo_parse_zone(char **buf, struct zoneinfo_zone *zone) {
    for (char *line = strtok_r(NULL, "\n", buf); line;
         line = strtok_r(NULL, "\n", buf)) {
        char *cp;
        char *ap;
        char *save_ptr;
        int64_t val;
        int field_idx;
        enum field_match_result match_res;

        cp = strtok_r(line, " ", &save_ptr);
        if (!cp) {
            return false;
        }

        field_idx = find_field(cp, zoneinfo_zone_spec_field_names, ZI_ZONE_SPEC_FIELD_COUNT);
        if (field_idx >= 0) {
            /* special field */
            if (field_idx == ZI_ZONE_SPEC_PAGESETS) {
                /* no mode fields we are interested in */
                return true;
            }

            /* protection field */
            ap = strtok_r(NULL, ")", &save_ptr);
            if (ap) {
                zoneinfo_parse_protection(ap, zone);
            }
            continue;
        }

        ap = strtok_r(NULL, " ", &save_ptr);
        if (!ap) {
            continue;
        }

        match_res = match_field(cp, ap, zoneinfo_zone_field_names, ZI_ZONE_FIELD_COUNT,
            &val, &field_idx);
        if (match_res == PARSE_FAIL) {
            return false;
        }
        if (match_res == PARSE_SUCCESS) {
            zone->fields.arr[field_idx] = val;
        }
        if (field_idx == ZI_ZONE_PRESENT && val == 0) {
            /* zone is not populated, stop parsing it */
            return true;
        }
    }
    return false;
}

static int zoneinfo_parse_node(char **buf, struct zoneinfo_node *node) {
    int fields_to_match = ZI_NODE_FIELD_COUNT;

    for (char *line = strtok_r(NULL, "\n", buf); line;
         line = strtok_r(NULL, "\n", buf)) {
        char *cp;
        char *ap;
        char *save_ptr;
        int64_t val;
        int field_idx;
        enum field_match_result match_res;

        cp = strtok_r(line, " ", &save_ptr);
        if (!cp) {
            return false;
        }

        ap = strtok_r(NULL, " ", &save_ptr);
        if (!ap) {
            return false;
        }

        match_res = match_field(cp, ap, zoneinfo_node_field_names, ZI_NODE_FIELD_COUNT,
            &val, &field_idx);
        if (match_res == PARSE_FAIL) {
            return false;
        }
        if (match_res == PARSE_SUCCESS) {
            node->fields.arr[field_idx] = val;
            fields_to_match--;
            if (!fields_to_match) {
                return true;
            }
        }
    }
    return false;
}

static int zoneinfo_parse(struct zoneinfo *zi) {
    static struct reread_data file_data = {
        .filename = ZONEINFO_PATH,
        .fd = -1,
    };
    char *buf;
    char *save_ptr;
    char *line;
    char zone_name[LINE_MAX + 1];
    struct zoneinfo_node *node = NULL;
    int node_idx = 0;
    int zone_idx = 0;

    memset(zi, 0, sizeof(struct zoneinfo));

    if ((buf = reread_file(&file_data)) == NULL) {
        return -1;
    }

    for (line = strtok_r(buf, "\n", &save_ptr); line;
         line = strtok_r(NULL, "\n", &save_ptr)) {
        int node_id;
        if (sscanf(line, "Node %d, zone %" STRINGIFY(LINE_MAX) "s", &node_id, zone_name) == 2) {
            if (!node || node->id != node_id) {
                /* new node is found */
                if (node) {
                    node->zone_count = zone_idx + 1;
                    node_idx++;
                    if (node_idx == MAX_NR_NODES) {
                        /* max node count exceeded */
                        ALOGE("%s parse error", file_data.filename);
                        return -1;
                    }
                }
                node = &zi->nodes[node_idx];
                node->id = node_id;
                zone_idx = 0;
                if (!zoneinfo_parse_node(&save_ptr, node)) {
                    ALOGE("%s parse error", file_data.filename);
                    return -1;
                }
            } else {
                /* new zone is found */
                zone_idx++;
            }
            if (!zoneinfo_parse_zone(&save_ptr, &node->zones[zone_idx])) {
                ALOGE("%s parse error", file_data.filename);
                return -1;
            }
            if (strstr(zone_name, "Normal")) {
                node->normal_idx = zone_idx;
            } else if (strstr(zone_name, "Movable")) {
                node->movable_idx = zone_idx;
            }
        }
    }
    if (!node) {
        ALOGE("%s parse error", file_data.filename);
        return -1;
    }
    node->zone_count = zone_idx + 1;
    zi->node_count = node_idx + 1;

    /* calculate totals fields */
    for (node_idx = 0; node_idx < zi->node_count; node_idx++) {
        node = &zi->nodes[node_idx];
        for (zone_idx = 0; zone_idx < node->zone_count; zone_idx++) {
            struct zoneinfo_zone *zone = &zi->nodes[node_idx].zones[zone_idx];
            zi->totalreserve_pages += zone->max_protection + zone->fields.field.high;
            zi->total_nr_free_rbin += zone->fields.field.nr_free_rbin;
            zi->total_nr_free_cma += zone->fields.field.nr_free_cma;
            zi->total_low += zone->fields.field.low;
            zi->total_min += zone->fields.field.min;
        }
        zi->total_inactive_file += node->fields.field.nr_inactive_file;
        zi->total_active_file += node->fields.field.nr_active_file;
    }
    return 0;
}

static int zoneinfo_parse_low_version(struct zoneinfo *zi) {
    static struct reread_data file_data = {
        .filename = ZONEINFO_PATH,
        .fd = -1,
    };
    char *buf;
    char *save_ptr;
    char *line;
    char zone_name[LINE_MAX + 1];
    struct zoneinfo_node *node = NULL;
    int node_idx = 0;
    int zone_idx = 0;

    memset(zi, 0, sizeof(struct zoneinfo));

    if ((buf = reread_file(&file_data)) == NULL) {
        return -1;
    }

    for (line = strtok_r(buf, "\n", &save_ptr); line;
         line = strtok_r(NULL, "\n", &save_ptr)) {
        int node_id;
        if(line!=NULL)
        if (sscanf(line, "Node %d, zone %" STRINGIFY(LINE_MAX) "s", &node_id, zone_name) == 2) {
            if (!node || node->id != node_id) {
                /* new node is found */
                if (node) {
                    node->zone_count = zone_idx + 1;
                    node_idx++;
                    if (node_idx == MAX_NR_NODES) {
                        /* max node count exceeded */
                        ALOGE("%s parse error", file_data.filename);
                        return -1;
                    }
                }
                node = &zi->nodes[node_idx];
                node->id = node_id;
                zone_idx = 0;
            } else {
                /* new zone is found */
                zone_idx++;
            }
            if (!zoneinfo_parse_zone_and_node(&save_ptr, &node->zones[zone_idx], node)) {
                ALOGE("%s parse error", file_data.filename);
                return -1;
            }
            if (strstr(zone_name, "Normal")) {
                node->normal_idx = zone_idx;
            } else if (strstr(zone_name, "Movable")) {
                node->movable_idx = zone_idx;
            }
        }
    }
    if (!node) {
        ALOGE("%s parse error", file_data.filename);
        return -1;
    }
    node->zone_count = zone_idx + 1;
    zi->node_count = node_idx + 1;

    /* calculate totals fields */
    for (node_idx = 0; node_idx < zi->node_count; node_idx++) {
        node = &zi->nodes[node_idx];
        for (zone_idx = 0; zone_idx < node->zone_count; zone_idx++) {
            struct zoneinfo_zone *zone = &zi->nodes[node_idx].zones[zone_idx];
            zi->totalreserve_pages += zone->max_protection + zone->fields.field.high;
            zi->total_nr_free_rbin += zone->fields.field.nr_free_rbin;
            zi->total_nr_free_cma += zone->fields.field.nr_free_cma;
            zi->total_low += zone->fields.field.low;
            zi->total_min += zone->fields.field.min;
        }
        zi->total_inactive_file += node->fields.field.nr_inactive_file;
        zi->total_active_file += node->fields.field.nr_active_file;
        //zi->total_workingset_refault += node->fields.field.workingset_refault;
    }
    return 0;
}
static int zoneinfo_parse_common(struct zoneinfo *zi){
    static bool use_latest_parser = true;
    static bool firsttime=true;
    int result = 0;

    if(firsttime){
        struct zoneinfo zi_old;
        struct zoneinfo zi_latest;

        zoneinfo_parse(&zi_latest);
        zoneinfo_parse_low_version(&zi_old);

        if(zi_old.total_low > zi_latest.total_low){
            ALOGI("Use the zoneinfo Parser for the low version kernel");
            use_latest_parser = false;
        }
        firsttime = false;
    }

    if(use_latest_parser) {
        result = zoneinfo_parse(zi);
    }
    else {
        result = zoneinfo_parse_low_version(zi);
    }

    return result;
}
/* /proc/meminfo parsing routines */
static bool meminfo_parse_line(char *line, union meminfo *mi) {
    char *cp = line;
    char *ap;
    char *save_ptr;
    int64_t val;
    int field_idx;
    enum field_match_result match_res;

    cp = strtok_r(line, " ", &save_ptr);
    if (!cp) {
        return false;
    }

    ap = strtok_r(NULL, " ", &save_ptr);
    if (!ap) {
        return false;
    }

    match_res = match_field(cp, ap, meminfo_field_names, MI_FIELD_COUNT,
        &val, &field_idx);
    if (match_res == PARSE_SUCCESS) {
        mi->arr[field_idx] = val / page_k;
    }
    return (match_res != PARSE_FAIL);
}

static int meminfo_parse(union meminfo *mi) {
    static struct reread_data file_data = {
        .filename = MEMINFO_PATH,
        .fd = -1,
    };
    char *buf;
    char *save_ptr;
    char *line;

    memset(mi, 0, sizeof(union meminfo));

    if ((buf = reread_file(&file_data)) == NULL) {
        return -1;
    }

    for (line = strtok_r(buf, "\n", &save_ptr); line;
         line = strtok_r(NULL, "\n", &save_ptr)) {
        if (!meminfo_parse_line(line, mi)) {
            ALOGE("%s parse error", file_data.filename);
            return -1;
        }
    }
    mi->field.nr_file_pages = mi->field.cached + mi->field.swap_cached +
        mi->field.buffers;

    return 0;
}

static bool meminfo_extra_parse_line(char *line, union meminfo_extra *mi_extra) {
    char *cp = line;
    char *ap;
    char *save_ptr;
    int64_t val;
    int field_idx;
    enum field_match_result match_res;

    cp = strtok_r(line, " ", &save_ptr);
    if (!cp) {
        return false;
    }

    ap = strtok_r(NULL, " ", &save_ptr);
    if (!ap) {
        return false;
    }

    match_res = match_field(cp, ap, meminfo_extra_field_names, MI_EXTRA_FIELD_COUNT,
        &val, &field_idx);
    if (match_res == PARSE_SUCCESS) {
        mi_extra->arr[field_idx] = val / page_k;
    }
    return (match_res != PARSE_FAIL);
}

static int meminfo_extra_parse(union meminfo_extra *mi_extra) {
    static bool use_meminfo = false;
    static struct reread_data file_data = {
        .filename = MEMINFO_EXTRA_PATH,
        .fd = -1,
    };
    static struct reread_data file_data_meminfo = {
        .filename = MEMINFO_PATH,
        .fd = -1,
    };
    char *buf;
    char *save_ptr;
    char *line;

    memset(mi_extra, 0, sizeof(union meminfo_extra));

    if(!use_meminfo) {
        if ((buf = reread_file(&file_data)) == NULL) {
            use_meminfo = true;
            goto meminfo_use;
        }

        for (line = strtok_r(buf, "\n", &save_ptr); line;
             line = strtok_r(NULL, "\n", &save_ptr)) {
            if (!meminfo_extra_parse_line(line, mi_extra)) {
                ALOGE("%s parse error", file_data.filename);
                return -1;
            }
        }
    }

meminfo_use:
    if(use_meminfo) {
        if ((buf = reread_file(&file_data_meminfo)) == NULL) {
            return -1;
        }

        for (line = strtok_r(buf, "\n", &save_ptr); line;
             line = strtok_r(NULL, "\n", &save_ptr)) {
            if (!meminfo_extra_parse_line(line, mi_extra)) {
                ALOGE("%s parse error", file_data_meminfo.filename);
                return -1;
            }
        }

        mi_extra->field.system_heap = mi_extra->field.system + mi_extra->field.system_uncached;
        mi_extra->field.vmalloc_api_size = mi_extra->field.vmallocused;
    }
    return 0;
}

/* /proc/vmstat parsing routines */
static bool vmstat_parse_line(char *line, union vmstat *vs) {
    char *cp;
    char *ap;
    char *save_ptr;
    int64_t val;
    int field_idx;
    enum field_match_result match_res;

    cp = strtok_r(line, " ", &save_ptr);
    if (!cp) {
        return false;
    }

    ap = strtok_r(NULL, " ", &save_ptr);
    if (!ap) {
        return false;
    }

    match_res = match_field(cp, ap, vmstat_field_names, VS_FIELD_COUNT,
        &val, &field_idx);
    if (match_res == PARSE_SUCCESS) {
        vs->arr[field_idx] = val;
    }
    return (match_res != PARSE_FAIL);
}

static int vmstat_parse(union vmstat *vs) {
    static struct reread_data file_data = {
        .filename = VMSTAT_PATH,
        .fd = -1,
    };
    char *buf;
    char *save_ptr;
    char *line;

    memset(vs, 0, sizeof(union vmstat));

    /*
     * Per-zone related info need not present. Prefill them.
     * If exist, they can be overridden. This change helps
     * us to check which all zone info we can look into.
     */
    vs->field.pgskip_dma = vs->field.pgskip_high = -EINVAL;
    if ((buf = reread_file(&file_data)) == NULL) {
        return -1;
    }

    for (line = strtok_r(buf, "\n", &save_ptr); line;
         line = strtok_r(NULL, "\n", &save_ptr)) {
        if (!vmstat_parse_line(line, vs)) {
            ALOGE("%s parse error", file_data.filename);
            return -1;
        }
    }

    return 0;
}

static int psi_parse(struct reread_data *file_data, struct psi_stats stats[], bool full) {
    char *buf;
    char *save_ptr;
    char *line;

    if ((buf = reread_file(file_data)) == NULL) {
        return -1;
    }

    line = strtok_r(buf, "\n", &save_ptr);
    if (parse_psi_line(line, PSI_SOME, stats)) {
        return -1;
    }
    if (full) {
        line = strtok_r(NULL, "\n", &save_ptr);
        if (parse_psi_line(line, PSI_FULL, stats)) {
            return -1;
        }
    }

    return 0;
}

static int psi_parse_mem(struct psi_data *psi_data) {
    static struct reread_data file_data = {
        .filename = PSI_PATH_MEMORY,
        .fd = -1,
    };
    return psi_parse(&file_data, psi_data->mem_stats, true);
}

/*
 * After the initial memory pressure event is received lmkd schedules periodic wakeups to check
 * the memory conditions and kill if needed (polling). This is done because pressure events are
 * rate-limited and memory conditions can change in between events. Therefore after the initial
 * event there might be multiple wakeups. This function records the wakeup information such as the
 * timestamps of the last event and the last wakeup, the number of wakeups since the last event
 * and how many of those wakeups were skipped (some wakeups are skipped if previously killed
 * process is still freeing its memory).
 */
static void record_wakeup_time(struct timespec *tm, enum wakeup_reason reason,
                               struct wakeup_info *wi) {
    wi->prev_wakeup_tm = wi->wakeup_tm;
    wi->wakeup_tm = *tm;
    if (reason == Event) {
        wi->last_event_tm = *tm;
        wi->wakeups_since_event = 0;
        wi->skipped_wakeups = 0;
    } else {
        wi->wakeups_since_event++;
    }
}

static void killinfo_log(struct proc* procp, int min_oom_score, int rss_kb,
                         int swap_kb, int kill_reason, union meminfo *mi,
                         struct wakeup_info *wi, struct timespec *tm) {
    /* log process information */
    android_log_write_int32(ctx, procp->pid);
    android_log_write_int32(ctx, procp->uid);
    android_log_write_int32(ctx, procp->oomadj);
    android_log_write_int32(ctx, min_oom_score);
    android_log_write_int32(ctx, (int32_t)min(rss_kb, INT32_MAX));
    android_log_write_int32(ctx, kill_reason);

    /* log meminfo fields */
    for (int field_idx = 0; field_idx < MI_FIELD_COUNT; field_idx++) {
        android_log_write_int32(ctx, (int32_t)min(mi->arr[field_idx] * page_k, INT32_MAX));
    }

    /* log lmkd wakeup information */
    android_log_write_int32(ctx, (int32_t)get_time_diff_ms(&wi->last_event_tm, tm));
    android_log_write_int32(ctx, (int32_t)get_time_diff_ms(&wi->prev_wakeup_tm, tm));
    android_log_write_int32(ctx, wi->wakeups_since_event);
    android_log_write_int32(ctx, wi->skipped_wakeups);
    android_log_write_int32(ctx, (int32_t)min(swap_kb, INT32_MAX));

    android_log_write_int32(ctx, (int32_t)(result_freelimit_val / 256)  );

    android_log_write_list(ctx, LOG_ID_EVENTS);
    android_log_reset(ctx);
}

/*
 * no strtok_r since that modifies buffer and we want to use multiline sscanf
 */
static char *nextln(char *buf)
{
    char *x;

    x = static_cast<char*>(memchr(buf, '\n', strlen(buf)));
    if (!x)
        return buf + strlen(buf);
    return x + 1;
}

static int parse_one_zone_watermark(char *buf, struct watermark_info *w)
{
    char *start = buf;
    int nargs;
    int ret = 0;

    while (*buf) {
        nargs = sscanf(buf, "Node %*u, zone %" STRINGIFY(LINE_MAX) "s", w->name);
        buf = nextln(buf);
        if (nargs == 1) {
            break;
        }
    }

    while(*buf) {
        nargs = sscanf(buf,
                    " pages free %d"
                    " min %*d"
                    " low %*d"
                    " high %d"
                    " spanned %*d"
                    " present %d"
                    " managed %*d",
                    &w->free, &w->high, &w->present);
        buf = nextln(buf);
        if (nargs == 3) {
            break;
        }
    }

    while(*buf) {
        nargs = sscanf(buf,
                    " protection: (%d, %d, %d, %d, %d, %d)",
                    &w->lowmem_reserve[0], &w->lowmem_reserve[1],
                    &w->lowmem_reserve[2], &w->lowmem_reserve[3],
                    &w->lowmem_reserve[4], &w->lowmem_reserve[5]);
        buf = nextln(buf);
        if (nargs >= 1) {
            break;
        }
    }

    while(*buf) {
        nargs = sscanf(buf,
                    " nr_zone_inactive_anon %d"
                    " nr_zone_active_anon %d"
                    " nr_zone_inactive_file %d"
                    " nr_zone_active_file %d",
                    &w->inactive_anon, &w->active_anon,
                    &w->inactive_file, &w->active_file);
        buf = nextln(buf);
        if (nargs == 4) {
            break;
        }
    }

    while (*buf) {
        nargs = sscanf(buf, " nr_free_cma %u", &w->cma);
        buf = nextln(buf);
        if (nargs == 1) {
            ret = buf - start;
            break;
        }
    }

    return ret;
}

/* QC Code
static void trace_log(const char *fmt, ...)
{
    char buf[PAGE_SIZE];
    va_list ap;
    static int fd = -1;
    ssize_t len, ret;

    if (fd < 0) {
        fd = open(TRACE_MARKER_PATH, O_WRONLY | O_CLOEXEC);
        if (fd < 0) {
            ALOGE("Error opening " TRACE_MARKER_PATH "; errno=%d",
                errno);
            return;
        }
    }

    va_start(ap, fmt);
    vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);

    len = strlen(buf);
    ret = TEMP_FAILURE_RETRY(write(fd, buf, len));
    if (ret < 0) {
        if (errno != EBADF) {
            ALOGE("Error writing " TRACE_MARKER_PATH ";errno=%d", errno);
            close(fd);
            fd = -1;
        }
        return;
    } else if (ret < len) {
        ALOGE("Short write on " TRACE_MARKER_PATH "; length=%zd", ret);
    }
}
*/

#define ULMK_LOG(X, fmt...) ({ \
    ALOG##X(fmt);              \
})
/*    trace_log(fmt);            \
})
*/

static int file_cache_to_adj(enum vmpressure_level __unused lvl, int nr_free,
int nr_file)
{
    int min_score_adj = OOM_SCORE_ADJ_MAX + 1;
    int minfree;
    int i;
    int crit_minfree;
    int s_crit_adj_level = level_oomadj[VMPRESS_LEVEL_SUPER_CRITICAL];

    /*
     * Below condition is to catch the zones where the file pages
     * are not allowed to, eg: Movable zone.
     * A corner case is where file_cache = 0 in the allowed zones
     * which is a very rare scenario.
     */
    if (!nr_file)
        goto out;

    for (i = 0; i < lowmem_targets_size; i++) {
        minfree = lowmem_minfree[i];
        if (nr_file < minfree) {
            min_score_adj = lowmem_adj[i];
            break;
        }
    }

    crit_minfree = lowmem_minfree[lowmem_targets_size - 1];
    if (lowmem_targets_size >= 2) {
        crit_minfree = lowmem_minfree[lowmem_targets_size - 1] +
                    (lowmem_minfree[lowmem_targets_size - 1] -
                    lowmem_minfree[lowmem_targets_size - 2]);
    }

    /* Adjust the selected adj in accordance with pressure. */
    if (s_crit_event && !s_crit_event_upgraded && (min_score_adj > s_crit_adj_level)) {
        min_score_adj = s_crit_adj_level;
    } else {
        if (s_crit_event_upgraded &&
                nr_free < lowmem_minfree[lowmem_targets_size -1] &&
                nr_file < crit_minfree &&
                min_score_adj > s_crit_adj_level) {
            min_score_adj = s_crit_adj_level;
        }
    }

out:
    /*
     * If event is upgraded, just allow one kill in that window. This
     * is to avoid the aggressiveness of kills by upgrading the event.
     */
    if (s_crit_event_upgraded)
	    s_crit_event_upgraded = s_crit_event = false;
    if (debug_process_killing)
        ULMK_LOG(E, "adj:%d file_cache: %d\n", min_score_adj, nr_file);
    return min_score_adj;
}

/*
 * Returns OOM_XCORE_ADJ_MAX + 1  on parsing error.
 */
static int zone_watermarks_ok(enum vmpressure_level level)
{
    static struct reread_data file_data = {
        .filename = ZONEINFO_PATH,
        .fd = -1,
    };
    char *buf;
    char *offset;
    struct watermark_info w[MAX_NR_ZONES];
    static union vmstat vs1, vs2;
    int zone_id, i, nr, present_zones = 0;
    bool lowmem_reserve_ok[MAX_NR_ZONES];
    int nr_file = 0;
    int min_score_adj = OOM_SCORE_ADJ_MAX + 1;

    if ((buf = reread_file(&file_data)) == NULL) {
        return min_score_adj;
    }

    memset(&w, 0, sizeof(w));
    memset(&lowmem_reserve_ok, 0, sizeof(lowmem_reserve_ok));
    offset = buf;

    /* Parse complete zone info. */
    for (zone_id = 0; zone_id < MAX_NR_ZONES; zone_id++, present_zones++) {
        nr = parse_one_zone_watermark(offset, &w[zone_id]);
        if (!nr)
            break;
        offset += nr;
    }
    if (!present_zones)
        goto out;

    if (vmstat_parse(&vs1) < 0) {
        ULMK_LOG(E, "Failed to parse vmstat!");
        goto out;
    }

    for (zone_id = 0, i = VS_PGSKIP_FIRST_ZONE;
            i <= VS_PGSKIP_LAST_ZONE && zone_id < present_zones; ++i) {
        if (vs1.arr[i] == -EINVAL)
            continue;
        /*
         * If no page is skipped while reclaiming, then consider this
         * zone file cache stats.
         */
        if (!(vs1.arr[i] - vs2.arr[i]))
            nr_file += w[zone_id].inactive_file + w[zone_id].active_file;

        ++zone_id;
    }

    vs2 = vs1;
    for (zone_id = 0; zone_id < present_zones; zone_id++) {
        int margin;

        if (debug_process_killing) {
            ULMK_LOG(D, "Zone %s: free:%d high:%d cma:%d reserve:(%d %d %d)"
                " anon:(%d %d) file:(%d %d)\n",
                w[zone_id].name, w[zone_id].free, w[zone_id].high, w[zone_id].cma,
                w[zone_id].lowmem_reserve[0], w[zone_id].lowmem_reserve[1],
                w[zone_id].lowmem_reserve[2],
                w[zone_id].inactive_anon, w[zone_id].active_anon,
                w[zone_id].inactive_file, w[zone_id].active_file);
        }

        /* Zone is empty */
        if (!w[zone_id].present)
            continue;

        margin = w[zone_id].free - w[zone_id].cma - w[zone_id].high;
        for (i = 0; i < present_zones; i++)
            if (w[zone_id].lowmem_reserve[i] && (margin > w[zone_id].lowmem_reserve[i]))
                lowmem_reserve_ok[i] = true;

        if (!s_crit_event && (margin >= 0 || lowmem_reserve_ok[zone_id]))
            continue;

        return file_cache_to_adj(level, w[zone_id].free, nr_file);
    }

out:
    if (offset == buf)
        ALOGE("Parsing watermarks failed in %s", file_data.filename);

    return min_score_adj;
}

static long check_memboost() {
    static struct reread_data file_data = {
        .filename = INKERNEL_MEMBOOST_NODE_PATH,
        .fd = -1,
    };
    long memboost_val;
    char *buf;

    if ((buf = reread_file(&file_data)) == NULL) {
        use_camera_boost = false;
        use_camera_8k_boost = false;

        ALOGI("try to read memboost node but it is failed");

        return -1;
    }

    sscanf(buf, "%ld", &memboost_val);

    return memboost_val;
}

static struct proc *proc_adj_lru(int oomadj, int skipcount, struct timespec *curr_tm) {
    struct adjslot_list *tail = adjslot_tail(&procadjslot_list[ADJTOSLOT(oomadj)]);
    struct adjslot_list *head = &procadjslot_list[ADJTOSLOT(oomadj)];
    struct adjslot_list *picked = tail;
    struct proc *cur_proc;

    for(int i=0; i < skipcount; i++) {
        if(picked==NULL || picked->prev==NULL) {
            return NULL;
        } else if (head == picked){
            return NULL;
        }
        picked = picked->prev;
    }
    cur_proc = (struct proc *)picked;

    while ( cur_proc !=NULL && curr_tm->tv_sec != -1 &&
            (get_time_diff_ms(&(cur_proc->proc_start_time), curr_tm) <= PROC_START_KILL_DELAY_TIME)) {
        if(picked==NULL || picked->prev==NULL) {
            return NULL;
        } else if (head == picked){
            return NULL;
        }
        picked = picked->prev;
        if (debug_process_killing) ALOGI("skip proc : %d in getlru ", cur_proc->pid);
        cur_proc = (struct proc *)picked;
    }

    if ( head == picked ) return NULL;
    return (struct proc *)picked;
}

static struct proc *proc_get_heaviest(int oomadj, bool checklesstime, struct timespec *curr_tm) {
    struct adjslot_list *head = &procadjslot_list[ADJTOSLOT(oomadj)];
    struct adjslot_list *curr = head->next;
    struct proc *maxprocp = NULL;
    int maxsize = 0;
    while (curr != head) {
        struct proc *cur_proc = (struct proc *)curr;
        int pid = cur_proc->pid;
        long tasksize = proc_get_size(pid);

        if (tasksize < 0) {
            struct adjslot_list *next = curr->next;
            pid_remove(pid);
            curr = next;
            continue;
        }

        if ( checklesstime && pid == launched_app_pid ){
            curr = curr->next;
            continue;
        }
        if ( enable_reentry_lmk && (cur_proc->stateval == PROCESS_STATE_ACTIVE_LAUNCH || cur_proc->stateval == PROCESS_STATE_NAP_LAUNCH) ){
            curr = curr->next;
            continue;
        }

        if( kill_keep_except && cur_proc->stateval == PROCESS_STATE_CACHED_EXCEPT ){
            curr = curr->next;
            continue;
        }

        if( cur_proc->stateval == PROCESS_STATE_BOOTING_EXCEPTION &&
            (get_time_diff_ms(&(cur_proc->proc_start_time), &boot_tm) <= BOOT_EXCEPTION_RUNNING_TIME)){
            curr = curr->next;
            continue;
        }

        if ( cameramode_killboost && camera_idx==0 && cur_proc->stateval==PROCESS_STATE_CAMERA_RELATED ) { // gallery ..
            if(kill_keep_except || last_killed_adj > 850) {
                curr = curr->next;
                continue;
            }
        }
        if ( curr_tm != NULL && curr_tm->tv_sec != -1 &&
            (get_time_diff_ms(&(cur_proc->proc_start_time), curr_tm) <= PROC_START_KILL_DELAY_TIME)){
            if (debug_process_killing) ALOGI("skip proc : %d in heaviest ", cur_proc->pid);
            curr = curr->next;
            continue;
        }

        if (tasksize > maxsize) {
            maxsize = tasksize;
            maxprocp = cur_proc;
        }
        curr = curr->next;
    }
    return maxprocp;
}

/*
static struct proc *proc_adj_lru(int oomadj) {
    return (struct proc *)adjslot_tail(&procadjslot_list[ADJTOSLOT(oomadj)]);
}

static struct proc *proc_get_heaviest(int oomadj) {
    struct adjslot_list *head = &procadjslot_list[ADJTOSLOT(oomadj)];
    struct adjslot_list *curr = head->next;
    struct proc *maxprocp = NULL;
    int maxsize = 0;

    //Filter out PApps
    struct proc *maxprocp_pa = NULL;
    int maxsize_pa = 0;
    char *tmp_taskname;
    char buf[LINE_MAX];

    while (curr != head) {
        int pid = ((struct proc *)curr)->pid;
        long tasksize = proc_get_size(pid);
        if (tasksize < 0) {
            struct adjslot_list *next = curr->next;
            pid_remove(pid);
            curr = next;
        } else {
            tmp_taskname = proc_get_name(pid, buf, sizeof(buf));
            if (enable_preferred_apps && tmp_taskname != NULL && strstr(preferred_apps, tmp_taskname)) {
                if (tasksize > maxsize_pa) {
                    maxsize_pa = tasksize;
                    maxprocp_pa = (struct proc *)curr;
                }
            } else {
                if (tasksize > maxsize) {
                    maxsize = tasksize;
                    maxprocp = (struct proc *)curr;
                }
            }
            curr = curr->next;
        }
    }
    if (maxsize > 0) {
        return maxprocp;
    } else {
        return maxprocp_pa;
    }
}
*/
static void set_process_group_and_prio(int pid, const std::vector<std::string>& profiles,
                                       int prio) {
    DIR* d;
    char proc_path[PATH_MAX];
    struct dirent* de;

    snprintf(proc_path, sizeof(proc_path), "/proc/%d/task", pid);
    if (!(d = opendir(proc_path))) {
        ALOGW("Failed to open %s; errno=%d: process pid(%d) might have died", proc_path, errno,
              pid);
        return;
    }

    while ((de = readdir(d))) {
        int t_pid;

        if (de->d_name[0] == '.') continue;
        t_pid = atoi(de->d_name);

        if (!t_pid) {
            ALOGW("Failed to get t_pid for '%s' of pid(%d)", de->d_name, pid);
            continue;
        }

        if (setpriority(PRIO_PROCESS, t_pid, prio) && errno != ESRCH) {
            ALOGW("Unable to raise priority of killing t_pid (%d): errno=%d", t_pid, errno);
        }

        if (!SetTaskProfiles(t_pid, profiles, true)) {
            ALOGW("Failed to set task_profiles on pid(%d) t_pid(%d)", pid, t_pid);
            continue;
        }
    }
    closedir(d);
}

/*
 * Allow lmkd to "find" shell scripts with oom_score_adj >= 0
 * Since we are not informed when a shell script exit, the generated
 * list may be obsolete. This case is handled by the loop in
 * find_and_kill_processes.
 */
static void proc_get_script(void)
{
    static DIR* d = NULL;
    struct dirent* de;
    char path[PATH_MAX];
    static char line[LINE_MAX];
    ssize_t len;
    int fd, oomadj = OOM_SCORE_ADJ_MIN;
    uint32_t pid;
    struct proc *procp;
    long total_vm;
    static bool retry_eligible = false;
    struct timespec curr_tm;
    static struct timespec last_traverse_time;
    static bool check_time = false;

    if(check_time) {
	    clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm);
	    if (get_time_diff_ms(&last_traverse_time, &curr_tm) <
			    PSI_PROC_TRAVERSE_DELAY_MS)
		    return;
    }
repeat:
    if (!d && !(d = opendir("/proc"))) {
        ALOGE("Failed to open /proc");
        return;
    }

    while ((de = readdir(d))) {
        if (sscanf(de->d_name, "%u", &pid) != 1)
            continue;

        /* Don't attempt to kill init */
        if (pid == 1)
            continue;

        /*
	 * Don't attempt to kill kthreads. Rely on total_vm for this.
	 */
        total_vm = proc_get_vm(pid);
        if (total_vm <= 0)
            continue;

        snprintf(path, sizeof(path), "/proc/%u/oom_score_adj", pid);
        fd = open(path, O_RDONLY | O_CLOEXEC);
        if (fd < 0)
            continue;

        len = read_all(fd, line, sizeof(line) - 1);
        close(fd);

        if (len < 0)
            continue;

        line[LINE_MAX - 1] = '\0';

        if (sscanf(line, "%d", &oomadj) != 1) {
            ALOGE("Parsing oomadj %s failed", line);
            continue;
        }

        if (oomadj < 0)
            continue;

        procp = pid_lookup(pid);
        if (!procp) {
            procp = static_cast<struct proc *>(malloc(sizeof(*procp)));
            if (!procp)
                break;

            procp->pid = pid;
            procp->uid = 0;
            procp->oomadj = oomadj;
            proc_insert(procp);
	    retry_eligible = true;
	    check_time = false;
	    ALOGI("proc_get_script: Added a task to kill list");
	    return;
        } else {
            ALOGD("Entry already exists %d: %s\n", procp->pid, proc_get_name(pid, path, sizeof(path)));
        }
    }
    closedir(d);
    d = NULL;
    if (retry_eligible) {
	    retry_eligible = false;
	    goto repeat;
    }
    check_time = true;
    clock_gettime(CLOCK_MONOTONIC_COARSE, &last_traverse_time);
    ALOGI("proc_get_script: None tasks are added to kill list");
}

static bool proc_check_is_browser(int oomadj) {
    struct adjslot_list *head = &procadjslot_list[ADJTOSLOT(oomadj)];
    struct adjslot_list *curr = head->next;
    while (curr != head) {
        int stateval = ((struct proc *)curr)->stateval;
        int pid = ((struct proc *)curr)->pid;

        if( stateval == PROCESS_STATE_VISIBLE_BROWSER ) {
            long tasksize = proc_get_size(pid);
            if (tasksize < 0) {
                struct adjslot_list *next = curr->next;
                pid_remove(pid);
                curr = next;
                continue;
            } else {
                //ALOGI("web browser is foreground now!! pid : %d", ((struct proc *)curr)->pid );
                return true;
            }
        }
        curr = curr->next;
    }
    return false;
}
static bool get_is_browser_visible() {
    for(int i = OOM_SCORE_ADJ_FOREGROUND; i < PERCEPTIBLE_APP_ADJ; i = i + 1){
        if(proc_check_is_browser(i)){
            return true;
        }
    }
    return false;
}

static void proc_get_count(int oomadj, int *cached_count, int *sandbox_count) {
    struct adjslot_list *head = &procadjslot_list[ADJTOSLOT(oomadj)];
    struct adjslot_list *curr = head->next;
    while (curr != head) {
        int stateval = ((struct proc *)curr)->stateval;
        if( stateval == PROCESS_STATE_CACHED_ACTIVITY || (stateval >= PROCESS_STATE_RECENT_ACTIVITY_LATEST && stateval <= PROCESS_STATE_RECENT_ACTIVITY_MAXIMUM) ) {
            (*cached_count)++;
        }
        if( stateval == PROCESS_STATE_CACHED_SANDBOX ) {
            (*sandbox_count)++;
        }
        curr = curr->next;
    }
}
static void get_cached_processes_count(int *cached_count, int *sandbox_count) {
    for(int i = OOM_SCORE_ADJ_CACHED_MIN; i < OOM_SCORE_ADJ_CACHED_MAX; i = i + 10){
        proc_get_count(i, cached_count, sandbox_count);
    }
    if (bora_policy_enable) {
        int min_adj =  OOM_SCORE_ADJ_BACKUPAPP + (PROCESS_STATE_RECENT_ACTIVITY_LATEST - 100);
        int max_adj =  OOM_SCORE_ADJ_BACKUPAPP + (PROCESS_STATE_RECENT_ACTIVITY_MAXIMUM - 100);
        for(int i = min_adj; i <= max_adj; i++){
            proc_get_count(i, cached_count, sandbox_count);
        }
    }
    proc_get_count(OOM_SCORE_ADJ_CACHED_MAX, cached_count, sandbox_count);
}

static bool is_kill_pending(void) {
    char buf[24];

    if (last_kill_pid_or_fd < 0) {
        return false;
    }

    if (pidfd_supported) {
        return true;
    }

    /* when pidfd is not supported base the decision on /proc/<pid> existence */
    snprintf(buf, sizeof(buf), "/proc/%d/", last_kill_pid_or_fd);
    if (access(buf, F_OK) == 0) {
        return true;
    }

    return false;
}

static bool is_waiting_for_kill(void) {
    return pidfd_supported && last_kill_pid_or_fd >= 0;
}

static void stop_wait_for_proc_kill(bool finished) {
    struct epoll_event epev;

    if (last_kill_pid_or_fd < 0) {
        return;
    }

    if (debug_process_killing) {
        struct timespec curr_tm;

        if (clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm) != 0) {
            /*
             * curr_tm is used here merely to report kill duration, so this failure is not fatal.
             * Log an error and continue.
             */
            ALOGE("Failed to get current time");
        }

        if (finished) {
            ALOGI("Process got killed in %ldms",
                get_time_diff_ms(&last_kill_tm, &curr_tm));
        } else {
            ALOGI("Stop waiting for process kill after %ldms",
                get_time_diff_ms(&last_kill_tm, &curr_tm));
        }
    }

    if (pidfd_supported) {
        /* unregister fd */
        if (epoll_ctl(epollfd, EPOLL_CTL_DEL, last_kill_pid_or_fd, &epev)) {
            // Log an error and keep going
            ALOGE("epoll_ctl for last killed process failed; errno=%d", errno);
        }
        maxevents--;
        close(last_kill_pid_or_fd);
    }

    last_kill_pid_or_fd = -1;
}

static void kill_done_handler(int data __unused, uint32_t events __unused,
                              struct polling_params *poll_params) {
    stop_wait_for_proc_kill(true);
    poll_params->update = POLLING_RESUME;
}

static void start_wait_for_proc_kill(int pid_or_fd) {
    static struct event_handler_info kill_done_hinfo = { 0, kill_done_handler };
    struct epoll_event epev;

    if (last_kill_pid_or_fd >= 0) {
        /* Should not happen but if it does we should stop previous wait */
        ALOGE("Attempt to wait for a kill while another wait is in progress");
        stop_wait_for_proc_kill(false);
    }

    last_kill_pid_or_fd = pid_or_fd;

    if (!pidfd_supported) {
        /* If pidfd is not supported just store PID and exit */
        return;
    }

    epev.events = EPOLLIN;
    epev.data.ptr = (void *)&kill_done_hinfo;
    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, last_kill_pid_or_fd, &epev) != 0) {
        ALOGE("epoll_ctl for last kill failed; errno=%d", errno);
        close(last_kill_pid_or_fd);
        last_kill_pid_or_fd = -1;
        return;
    }
    maxevents++;
}

/* Kill one process specified by procp.  Returns the size (in pages) of the process killed */
static long kill_one_process(struct proc* procp, int min_oom_score, struct kill_info *ki,
                            union meminfo *mi, struct wakeup_info *wi, struct timespec *tm,
                            enum vmpressure_level level) {
    int pid = procp->pid;
    int pidfd = procp->pidfd;
    uid_t uid = procp->uid;
    char *taskname;
    int r;
    long result = -1;
    struct memory_stat *mem_st;
    struct kill_stat kill_st;
    int64_t tgid;
    int64_t rss_kb;
    int64_t swap_kb;
    char buf[PAGE_SIZE];

    if (!read_proc_status(pid, buf, sizeof(buf))) {
        goto out;
    }
    if (!parse_status_tag(buf, PROC_STATUS_TGID_FIELD, &tgid)) {
        ALOGE("Unable to parse tgid from /proc/%d/status", pid);
        goto out;
    }
    if (tgid != pid) {
        ALOGE("Possible pid reuse detected (pid %d, tgid %" PRId64 ")!", pid, tgid);
        goto out;
    }
    // Zombie processes will not have RSS / Swap fields.
    if (!parse_status_tag(buf, PROC_STATUS_RSS_FIELD, &rss_kb)) {
        goto out;
    }
    if (!parse_status_tag(buf, PROC_STATUS_SWAP_FIELD, &swap_kb)) {
        goto out;
    }

    taskname = proc_get_name(pid, buf, sizeof(buf));
    // taskname will point inside buf, do not reuse buf onwards.
    if (!taskname) {
        goto out;
    }

    mem_st = stats_read_memory_stat(per_app_memcg, pid, uid, rss_kb * 1024, swap_kb * 1024);

    if(procp->oomadj <= 100) {
        writesysrqtrigger();
    }

    TRACE_KILL_START(pid);

    /* CAP_KILL required */
    if (pidfd < 0) {
        start_wait_for_proc_kill(pid);
        r = kill(pid, SIGKILL);
    } else {
        start_wait_for_proc_kill(pidfd);
        r = sys_pidfd_send_signal(pidfd, SIGKILL, NULL, 0);
    }

    TRACE_KILL_END();

    if (r) {
        stop_wait_for_proc_kill(false);
        ALOGE("kill(%d): errno=%d", pid, errno);
        /* Delete process record even when we fail to kill so that we don't get stuck on it */
        goto out;
    }

    set_process_group_and_prio(pid, {"CPUSET_SP_FOREGROUND", "SCHED_SP_FOREGROUND"},
                               ANDROID_PRIORITY_HIGHEST);

    last_kill_tm = *tm;
    saved_last_kill_tm = last_kill_tm;

    inc_killcnt(procp->oomadj);

    if (ki) {
        kill_st.kill_reason = ki->kill_reason;
        kill_st.thrashing = ki->thrashing;
        kill_st.max_thrashing = ki->max_thrashing;
        killinfo_log(procp, min_oom_score, rss_kb, swap_kb, ki->kill_reason, mi, wi, tm);
        ALOGI("Reclaim '%s' (%d), uid %d, oom_score_adj %d, state %d to free %" PRId64 "kB rss, %" PRId64
              "kB swap; reason: %s", taskname, pid, uid, procp->oomadj, procp->stateval, rss_kb, swap_kb,
              ki->kill_desc);
    } else {
        kill_st.kill_reason = NONE;
        kill_st.thrashing = 0;
        kill_st.max_thrashing = 0;
        killinfo_log(procp, min_oom_score, rss_kb, swap_kb, NONE, mi, wi, tm);
        ALOGI("Reclaim '%s' (%d), uid %d, oom_score_adj %d, state %d to free %" PRId64 "kB rss, %" PRId64
              "kb swap", taskname, pid, uid, procp->oomadj, procp->stateval, rss_kb, swap_kb);
    }

    kill_st.uid = static_cast<int32_t>(uid);
    kill_st.taskname = taskname;
    kill_st.oom_score = procp->oomadj;
    kill_st.min_oom_score = min_oom_score;
    kill_st.free_mem_kb = mi->field.nr_free_pages * page_k;
    kill_st.free_swap_kb = mi->field.free_swap * page_k;
    stats_write_lmk_kill_occurred(&kill_st, mem_st);

    ctrl_data_write_lmk_kill_occurred((pid_t)pid, uid);

    if (use_camera_kill_mode_noswaprss && ki && ki->kill_reason == CAMERA_KILL_MODE) {
        result = rss_kb / page_k;
    } else {
        result = (rss_kb + swap_kb) / page_k;
    }

    lmkd_count++;
    if( level >= VMPRESS_LEVEL_CRITICAL ) lmkd_cricount++;

    last_killed_adj = procp->oomadj;
out:
    /*
     * WARNING: After pid_remove() procp is freed and can't be used!
     * Therefore placed at the end of the function.
     */
    pid_remove(pid);
    return result;
}

/*
 * Find one process to kill at or above the given oom_score_adj level.
 * Returns size of the killed process.
 */
static long find_and_kill_process(int min_score_adj, struct kill_info *ki, union meminfo *mi,
                                  struct wakeup_info *wi, struct timespec *tm,
                                  enum vmpressure_level level) {
    int i;
    long killed_size = 0;
    bool can_retry = true;
    bool lmk_state_change_start = false;

    int cached_count=0, sandbox_count=0;
    int cached_min=0;
    bool firststep = true;
    bool secondstep = true;
    struct timespec temp_curr_tm;
    bool checktime = false;
    bool checklesstime = false;
    int last_act_index = level_oomadj[VMPRESS_LEVEL_MEDIUM];
    int sandbox_count_limit = 1;

retry:
    get_cached_processes_count(&cached_count, &sandbox_count);
    if(get_is_browser_visible()){
        sandbox_count_limit = 4;
    }
    cached_min = bora_policy_enable ? 0 : lmkd_cached_proc_min;
    ALOGI("cached %d, sandbox(not0) %d",cached_count, sandbox_count);
    for (i = OOM_SCORE_ADJ_MAX; i >= min_score_adj; i--) {
        struct proc *procp;
        //bool cachedstep = false;
        int skipcount = 0;
        if( i == OOM_SCORE_ADJ_PREVIOUS && low_adj_kill_skip){
            continue;
        }
        if( i <= PERCEPTIBLE_LOW_APP_ADJ && low_adj_kill_skip){
            return KILL_SKIPPED;
        }
        if( use_new_strategy && enable_reentry_lmk && secondstep ) {
            if( ki != NULL && ki->kill_reason == CAMERA_KILL_MODE ) {
                // if camera kill mode, don't comeback last_act_index
                secondstep=true;
            } else if( i < level_oomadj[VMPRESS_LEVEL_MEDIUM] && level <= VMPRESS_LEVEL_MEDIUM ) {
                // adj under 850
                i = last_act_index;
                secondstep=false;
            }
        }
        while (true) {
            procp = (level >= VMPRESS_LEVEL_CRITICAL) ?
                proc_get_heaviest(i, checklesstime, tm) : proc_adj_lru(i,skipcount, tm);
            /*
            procp = kill_heaviest_task ?
                proc_get_heaviest(i) : proc_adj_lru(i,skipcount);
            */
            if (!procp)
                break;

            if(procp->pid == launched_app_pid){
                if(!checktime){
                    if (clock_gettime(CLOCK_MONOTONIC_COARSE, &temp_curr_tm) != 0) {
                        ALOGE("Failed to get current time in find_and_kill_processes");
                    } else {
                        checktime = true;
                    }
                }

                if ((get_time_diff_ms(&last_launched_time, &temp_curr_tm) <= LAUNCHED_APP_KILL_DELAY_TIME)) {
                    ALOGI("kill skip!! it is a launching process : %d", procp->pid);
                    checklesstime = true;
                    skipcount++;
                    continue;
                } else {
                    launched_app_pid = -1;
                }
            }
            if( enable_reentry_lmk && ( procp->stateval == PROCESS_STATE_ACTIVE_LAUNCH || procp->stateval == PROCESS_STATE_NAP_LAUNCH ) ){
                int tasksize = proc_get_size(procp->pid);
                if (tasksize < 0) {
                    pid_remove(procp->pid);
                } else {
                    skipcount++;
                }
                continue;
            }
            if( enable_reentry_lmk && procp->stateval == PROCESS_STATE_BOOTING_EXCEPTION &&
                (get_time_diff_ms(&(procp->proc_start_time), &boot_tm) <= BOOT_EXCEPTION_RUNNING_TIME) ){
                int tasksize = proc_get_size(procp->pid);
                if (tasksize < 0) {
                    pid_remove(procp->pid);
                } else {
                    skipcount++;
                }
                continue;
            }
            if( enable_reentry_lmk && level < VMPRESS_LEVEL_CRITICAL ) {
                if ( procp->stateval==PROCESS_STATE_CACHED_EXCEPT ) { // pallowlist and amsexception process
                    skipcount++;
                    continue;
                } else if ( cameramode_killboost && camera_idx==0 && procp->stateval==PROCESS_STATE_CAMERA_RELATED ) { // gallery ..
                    skipcount++;
                    continue;
                }

                if ( firststep ){
                    if ( procp->stateval == PROCESS_STATE_CACHED_ACTIVITY || procp->stateval == PROCESS_STATE_CACHED_ACTIVITY_CLIENT || procp->stateval == PROCESS_STATE_CACHED_SANDBOX ) {
                        skipcount++;
                        continue;
                    }
                } else if ( secondstep ){ // second step
                    if( cached_count <= cached_min ) {
                        if ( procp->stateval == PROCESS_STATE_CACHED_ACTIVITY ) {
                            if(last_act_index <= i) last_act_index = i;
                            skipcount++;
                            continue;
                        }
                    }
                    if ( sandbox_count <= sandbox_count_limit && procp->stateval == PROCESS_STATE_CACHED_SANDBOX) {
                        if(last_act_index <= i) last_act_index = i;
                        skipcount++;
                        continue;
                    }
                }
            }

            killed_size = kill_one_process(procp, min_score_adj, ki, mi, wi, tm, level);
            if (killed_size >= 0) {
                if (!lmk_state_change_start) {
                    lmk_state_change_start = true;
                    stats_write_lmk_state_changed(STATE_START);
                }
                break;
            }
        }
        if (killed_size) {
            break;
        }
        if( i == OOM_SCORE_ADJ_CACHED_MIN && level <= VMPRESS_LEVEL_MEDIUM ) {
            if( firststep && i == OOM_SCORE_ADJ_CACHED_MIN ) {
                firststep = false;
                i = OOM_SCORE_ADJ_MAX;
            }
        }
    }

    if (enable_proc_get_script && !killed_size && !min_score_adj && can_retry) {
        proc_get_script();
        can_retry = false;
        goto retry;
    }

    if (lmk_state_change_start) {
        stats_write_lmk_state_changed(STATE_STOP);
    }

    writelmkdcount();
    return killed_size;
}

static int64_t get_memory_usage(struct reread_data *file_data) {
    int64_t mem_usage;
    char *buf;

    if (access(file_data->filename, F_OK)) {
        return -1;
    }

    if ((buf = reread_file(file_data)) == NULL) {
        return -1;
    }

    if (!parse_int64(buf, &mem_usage)) {
        ALOGE("%s parse error", file_data->filename);
        return -1;
    }
    if (mem_usage == 0) {
        ALOGE("No memory!");
        return -1;
    }
    return mem_usage;
}

void record_low_pressure_levels(union meminfo *mi) {
    if (low_pressure_mem.min_nr_free_pages == -1 ||
        low_pressure_mem.min_nr_free_pages > mi->field.nr_free_pages) {
        if (debug_process_killing) {
            ALOGI("Low pressure min memory update from %" PRId64 " to %" PRId64,
                low_pressure_mem.min_nr_free_pages, mi->field.nr_free_pages);
        }
        low_pressure_mem.min_nr_free_pages = mi->field.nr_free_pages;
    }
    /*
     * Free memory at low vmpressure events occasionally gets spikes,
     * possibly a stale low vmpressure event with memory already
     * freed up (no memory pressure should have been reported).
     * Ignore large jumps in max_nr_free_pages that would mess up our stats.
     */
    if (low_pressure_mem.max_nr_free_pages == -1 ||
        (low_pressure_mem.max_nr_free_pages < mi->field.nr_free_pages &&
         mi->field.nr_free_pages - low_pressure_mem.max_nr_free_pages <
         low_pressure_mem.max_nr_free_pages * 0.1)) {
        if (debug_process_killing) {
            ALOGI("Low pressure max memory update from %" PRId64 " to %" PRId64,
                low_pressure_mem.max_nr_free_pages, mi->field.nr_free_pages);
        }
        low_pressure_mem.max_nr_free_pages = mi->field.nr_free_pages;
    }
}

enum vmpressure_level upgrade_level(enum vmpressure_level level) {
    return (enum vmpressure_level)((level < VMPRESS_LEVEL_CRITICAL) ?
        level + 1 : level);
}

enum vmpressure_level downgrade_level(enum vmpressure_level level) {
    return (enum vmpressure_level)((level > VMPRESS_LEVEL_LOW) ?
        level - 1 : level);
}

enum zone_watermark {
    WMARK_MIN = 0,
    WMARK_MINX2,
    WMARK_LOW,
    WMARK_HIGH,
    WMARK_NONE
};

struct zone_watermarks {
    int64_t nr_free_pages;
    int64_t cma_free;
    long high_wmark;
    long low_wmark;
    long min_wmark;
    int64_t file_active_inactive;
    long max_protection;
};

/*
 * Returns lowest breached watermark or WMARK_NONE.
 */
/* AOSP code, not used now
static enum zone_watermark get_lowest_watermark(union meminfo *mi,
                                                struct zone_watermarks *watermarks)
{
    int64_t nr_free_pages = mi->field.nr_free_pages - mi->field.cma_free - mi->field.free_rbin - mi->field.huge_page_pool;

    if (nr_free_pages < watermarks->min_wmark) {
        return WMARK_MIN;
    }
    if (nr_free_pages < watermarks->low_wmark) {
        return WMARK_LOW;
    }
    if (nr_free_pages < watermarks->high_wmark) {
        return WMARK_HIGH;
    }
    return WMARK_NONE;
}
*/
static enum zone_watermark zone_get_lowest_watermark(union meminfo *mi __unused,
                                                struct zone_watermarks *watermarks)
{
    int64_t nr_free_pages = watermarks->nr_free_pages - watermarks->cma_free;
    int64_t new_min_wmark = watermarks->min_wmark + (watermarks->min_wmark - watermarks->max_protection);

    if (new_min_wmark - watermarks->min_wmark > 2560) new_min_wmark = watermarks->min_wmark + 2560;  // +10MB

    if (watermarks->min_wmark == 0 || watermarks->low_wmark == 0) {
        return WMARK_NONE;
    }
    if (nr_free_pages < watermarks->min_wmark) {
        return WMARK_MIN;
    }
    if (nr_free_pages < new_min_wmark) {
        return WMARK_MINX2;
    }
    if (nr_free_pages < watermarks->low_wmark) {
        return WMARK_LOW;
    }
    if (nr_free_pages < watermarks->high_wmark) {
        return WMARK_HIGH;
    }
    return WMARK_NONE;
}

static enum zone_watermark custom_get_lowest_watermark(union meminfo *mi,
                                                struct zone_watermarks *watermarks)
{
    int64_t nr_free_pages = mi->field.nr_free_pages - mi->field.cma_free - mi->field.free_rbin - mi->field.huge_page_pool;
    int64_t freelimit_added = watermarks->low_wmark;

    freelimit_added = (lmkd_freelimit_val / 10.0) * (watermarks->low_wmark - watermarks->max_protection) - (watermarks->low_wmark - watermarks->max_protection);

    int64_t new_low_wmark = watermarks->low_wmark + freelimit_added;
    int64_t new_high_wmark = watermarks->high_wmark + freelimit_added;
    int64_t new_min_wmark = watermarks->min_wmark + (watermarks->min_wmark - watermarks->max_protection);

    result_freelimit_val = new_low_wmark;
    if(new_min_wmark - watermarks->min_wmark > 2560) new_min_wmark = watermarks->min_wmark + 2560;  // +10MB

    if(use_bg_keeping_adapt_tm) {
        kill_timeout_ms_med = 200 + (nr_free_pages * (800.0 / new_low_wmark));
        kill_timeout_ms_med = clamp(200, 1000, kill_timeout_ms_med);
    }

    if( nr_free_pages >= watermarks->low_wmark * 0.6){  // lowmemexcept
        low_adj_kill_skip = true && kill_keep_except;
    } else {
        low_adj_kill_skip = false;
    }

    if (nr_free_pages < watermarks->min_wmark) {
        return WMARK_MIN;
    }
    if (use_dr_kill_boost && nr_free_pages < new_min_wmark) {
        if(watermarks->max_protection <= 1280) {// only if protection size under 5MB use , drkill booster kill =>WMARK_MINX2
            return WMARK_MINX2;
        }
    }
    if (nr_free_pages < new_low_wmark) {
        return WMARK_LOW;
    }
    if (nr_free_pages < new_high_wmark) {
        return WMARK_HIGH;
    }
    return WMARK_NONE;
}

static void log_zone_watermarks(struct zoneinfo *zi,
                                struct zone_watermarks *wmarks) {
    int i, j;
    struct zoneinfo_node *node;
    union zoneinfo_zone_fields *zone_fields;

    for (i = 0; i < zi->node_count; i++) {
        node = &zi->nodes[i];

        for (j = 0; j < node->zone_count; j++) {
            zone_fields = &node->zones[j].fields;

            if (debug_process_killing) {
                ULMK_LOG(D, "Zone: %d nr_free_pages: %" PRId64 " min: %" PRId64
                     " low: %" PRId64 " high: %" PRId64 " present: %" PRId64
                     " nr_cma_free: %" PRId64 " max_protection: %" PRId64,
                     j, zone_fields->field.nr_free_pages,
                     zone_fields->field.min, zone_fields->field.low,
                     zone_fields->field.high, zone_fields->field.present,
                     zone_fields->field.nr_free_cma,
                     node->zones[j].max_protection);
            }
        }
    }

    if (debug_process_killing) {
        ULMK_LOG(D, "Aggregate wmarks: min: %ld low: %ld high: %ld",
             wmarks->min_wmark, wmarks->low_wmark, wmarks->high_wmark);
    }
}

void calc_zone_watermarks(struct zoneinfo *zi, struct zone_watermarks *watermarks, struct zone_watermarks *normal_watermarks, struct zone_watermarks *nomovable_watermarks) {
    struct zone_watermarks movable_watermarks;

    memset(watermarks, 0, sizeof(struct zone_watermarks));
    memset(normal_watermarks, 0, sizeof(struct zone_watermarks));
    memset(nomovable_watermarks, 0, sizeof(struct zone_watermarks));
    memset(&movable_watermarks, 0, sizeof(struct zone_watermarks));

    for (int node_idx = 0; node_idx < zi->node_count; node_idx++) {
        struct zoneinfo_node *node = &zi->nodes[node_idx];
        for (int zone_idx = 0; zone_idx < node->zone_count; zone_idx++) {
            struct zoneinfo_zone *zone = &node->zones[zone_idx];

            if (!zone->fields.field.present) {
                continue;
            }

            if(zone_idx == node->normal_idx) {
                normal_watermarks->nr_free_pages += zone->fields.field.nr_free_pages;
                normal_watermarks->cma_free += zone->fields.field.nr_free_cma;
                normal_watermarks->high_wmark += zone->max_protection + zone->fields.field.high;
                normal_watermarks->low_wmark += zone->max_protection + zone->fields.field.low;
                normal_watermarks->min_wmark += zone->max_protection + zone->fields.field.min;
                normal_watermarks->file_active_inactive += (zone->fields.field.nr_zone_inactive_file + zone->fields.field.nr_zone_active_file);
                normal_watermarks->max_protection += zone->max_protection;
            } else if(zone_idx == node->movable_idx) {
                is_movable_zone = true;
                movable_watermarks.nr_free_pages += zone->fields.field.nr_free_pages;
                movable_watermarks.cma_free += zone->fields.field.nr_free_cma;
                movable_watermarks.high_wmark += zone->max_protection + zone->fields.field.high;
                movable_watermarks.low_wmark += zone->max_protection + zone->fields.field.low;
                movable_watermarks.min_wmark += zone->max_protection + zone->fields.field.min;
                movable_watermarks.file_active_inactive += (zone->fields.field.nr_zone_inactive_file + zone->fields.field.nr_zone_active_file);
                movable_watermarks.max_protection += zone->max_protection;
            }
            watermarks->nr_free_pages += zone->fields.field.nr_free_pages;
            watermarks->cma_free += zone->fields.field.nr_free_cma;
            watermarks->high_wmark += zone->max_protection + zone->fields.field.high;
            watermarks->low_wmark += zone->max_protection + zone->fields.field.low;
            watermarks->min_wmark += zone->max_protection + zone->fields.field.min;
            watermarks->file_active_inactive += (zone->fields.field.nr_zone_inactive_file + zone->fields.field.nr_zone_active_file);
            watermarks->max_protection += zone->max_protection;
        }
    }

    nomovable_watermarks->nr_free_pages = watermarks->nr_free_pages - movable_watermarks.nr_free_pages;
    nomovable_watermarks->cma_free = watermarks->cma_free - movable_watermarks.cma_free;
    nomovable_watermarks->high_wmark = watermarks->high_wmark - movable_watermarks.high_wmark;
    nomovable_watermarks->low_wmark = watermarks->low_wmark - movable_watermarks.low_wmark;
    nomovable_watermarks->min_wmark = watermarks->min_wmark - movable_watermarks.min_wmark;
    nomovable_watermarks->file_active_inactive = watermarks->file_active_inactive - movable_watermarks.file_active_inactive;
    nomovable_watermarks->max_protection = watermarks->max_protection - movable_watermarks.max_protection;

    /*
    ALOGI("check normal_watermark value, nr_free_pages: %" PRId64 ", file_active_inactive: %" PRId64 " ", normal_watermarks->nr_free_pages, normal_watermarks->file_active_inactive);
    ALOGI("check movable_watermark value, nr_free_pages: %" PRId64 ", file_active_inactive: %" PRId64 " ", movable_watermarks.nr_free_pages, movable_watermarks.file_active_inactive);
    ALOGI("check all_watermark value, nr_free_pages: %" PRId64 ", file_active_inactive: %" PRId64 ", highwmark: %ld, lowwmark: %ld, minwmark: %ld ", nomovable_watermarks->nr_free_pages, nomovable_watermarks->file_active_inactive, nomovable_watermarks->high_wmark, nomovable_watermarks->low_wmark, nomovable_watermarks->min_wmark);
    */

    if(watermarks->low_wmark <= 0) {
        ALOGE("calculated value of zoneinfo_low is 0, so it is set as 100MB");
        watermarks->low_wmark = 25600;
    }

    if(use_qc_feature) {
        log_zone_watermarks(zi, watermarks);
    }
}

static void log_meminfo(union meminfo *mi, enum zone_watermark wmark)
{
    char wmark_str[LINE_MAX];

    if (wmark == WMARK_MIN) {
        strlcpy(wmark_str, "min", LINE_MAX);
    } else if (wmark == WMARK_LOW) {
        strlcpy(wmark_str, "low", LINE_MAX);
    } else if (wmark == WMARK_HIGH) {
        strlcpy(wmark_str, "high", LINE_MAX);
    } else {
        strlcpy(wmark_str, "none", LINE_MAX);
    }

    if (debug_process_killing) {
        ULMK_LOG(D, "smallest wmark breached: %s nr_free_pages: %" PRId64
             " active_anon: %" PRId64 " inactive_anon: %" PRId64
             " cma_free: %" PRId64, wmark_str, mi->field.nr_free_pages,
             mi->field.active_anon, mi->field.inactive_anon,
             mi->field.cma_free);
    }
}

static void log_pgskip_stats(union vmstat *vs, int64_t *init_pgskip)
{
    int64_t pgskip_deltas[VS_PGSKIP_LAST_ZONE - VS_PGSKIP_FIRST_ZONE + 1] = {0};
    unsigned int i;

    for (i = VS_PGSKIP_FIRST_ZONE; i <= VS_PGSKIP_LAST_ZONE; i++) {
        if (vs->arr[i] >= 0) {
            pgskip_deltas[PGSKIP_IDX(i)] = vs->arr[i] -
                                           init_pgskip[PGSKIP_IDX(i)];
        }
    }

    if (debug_process_killing) {
        ULMK_LOG(D, "pgskip deltas: DMA: %" PRId64 " Normal: %" PRId64 " High: %"
             PRId64 " Movable: %" PRId64,
             pgskip_deltas[PGSKIP_IDX(VS_PGSKIP_DMA)],
             pgskip_deltas[PGSKIP_IDX(VS_PGSKIP_NORMAL)],
             pgskip_deltas[PGSKIP_IDX(VS_PGSKIP_HIGH)],
             pgskip_deltas[PGSKIP_IDX(VS_PGSKIP_MOVABLE)]);
    }
}

static int calc_swap_utilization(union meminfo *mi) {
    int64_t swap_used = mi->field.total_swap - mi->field.free_swap;
    int64_t total_swappable = mi->field.active_anon + mi->field.inactive_anon +
                              mi->field.shmem + swap_used;
    return total_swappable > 0 ? (swap_used * 100) / total_swappable : 0;
}

static void mp_event_psi(int data, uint32_t events, struct polling_params *poll_params) {
    enum reclaim_state {
        NO_RECLAIM = 0,
        KSWAPD_RECLAIM,
        DIRECT_RECLAIM,
        DIRECT_RECLAIM_CUSTOM,
        KSWAPD_RECLAIM_CUSTOM,
        EMERGENCY_MEM,
    };
    static int64_t init_ws_refault;
    static int64_t prev_workingset_refault;
    static int64_t base_file_lru;
    static int64_t init_pgscan_kswapd;
    static int64_t init_pgscan_direct;
    static int64_t init_pgskip[VS_PGSKIP_LAST_ZONE - VS_PGSKIP_FIRST_ZONE + 1];
    static int64_t swap_low_threshold;
    static bool killing;
    static int thrashing_limit = thrashing_limit_pct;
    static struct zone_watermarks watermarks;
    static struct zone_watermarks normal_watermarks;
    static struct zone_watermarks nomovable_watermarks;
    //static struct timespec wmark_update_tm;
    static struct wakeup_info wi;
    static int64_t totalreserve_pages;
    static bool use_killpending=true;
    /* SystemSW2G SystemHealth, we do not use this code because we don't use perfd
    static struct timespec last_pa_update_tm;
    */
    static int64_t init_compact_stall;
    static struct timespec thrashing_reset_tm;
    static int64_t prev_thrash_growth = 0;
    static bool check_filecache = false;
    static int max_thrashing = 0;

    union meminfo mi;
    union vmstat vs;
    struct psi_data psi_data;
    struct timespec curr_tm;
    int64_t thrashing = 0;
    bool swap_is_low = false;
    enum vmpressure_level level = (enum vmpressure_level)data;
    enum kill_reasons kill_reason = NONE;
    bool cycle_after_kill = false;
    enum reclaim_state reclaim = NO_RECLAIM;
    enum zone_watermark wmark = WMARK_NONE;
    enum zone_watermark normal_wmark = WMARK_NONE;
    enum zone_watermark nomovable_wmark = WMARK_NONE;
    char kill_desc[LINE_MAX];
    bool cut_thrashing_limit = false;
    unsigned int i;
    int min_score_adj = 0;
    bool in_compaction = false;
    int swap_util = 0;
    long since_thrashing_reset_ms;
    int64_t workingset_refault_file;
    struct zoneinfo zi;
    bool is_lowcachemem = false;
    bool check_med_emkill = false;
    int check_med_emkill_count = 0;
    int64_t temp_file_active_inactive = low_cachemem_deadline_page_zone+1;
    long other_file;
    long other_free;
    int bonus_limit = 0;
    bool dr_kill_boost_upgrade_th = false;

    static unsigned long kill_skip_count = 0, kill_skip_count_swap = 0, kill_skip_count_freelimit = 0;
    int memboost=0;

/*
    ULMK_LOG(D, "%s pressure event %s", level_name[level], events ?
             "triggered" : "polling check");
*/
    if (clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm) != 0) {
        ALOGE("Failed to get current time");
        return;
    }

    record_wakeup_time(&curr_tm, events ? Event : Polling, &wi);
/*
    if (level == VMPRESS_LEVEL_MEDIUM) {
        if (enable_preferred_apps &&
                (get_time_diff_ms(&last_pa_update_tm, &curr_tm) >= pa_update_timeout_ms)) {
            perf_ux_engine_trigger(PAPP_OPCODE, preferred_apps);
            last_pa_update_tm = curr_tm;
        }
    }
*/
    bool kill_pending = is_kill_pending();

    if(use_bg_keeping_policy) {
        if(level <= VMPRESS_LEVEL_MEDIUM && psi_kill_keep_except) {
            if(use_emergency_kill) {
                kill_timeout_ms = kill_timeout_ms_ori;
            } else if(dr_killboost) {
                kill_timeout_ms = kill_timeout_ms_ori;
            } else if (get_time_diff_ms(&last_boost_tm, &curr_tm) <= LAUNCHED_CAMERA_MEMBOOST_TIME) {
                kill_timeout_ms = kill_timeout_ms_ori/2;
                kill_pending = true;
            } else if (cameramode_killboost) {
                kill_timeout_ms = kill_timeout_ms_ori;
                kill_pending = true;
            } else {
                kill_timeout_ms = kill_timeout_ms_med;
                kill_pending = true;
                if(get_time_diff_ms(&saved_last_kill_tm, &curr_tm) > static_cast<long>(kill_timeout_ms_ori)) {
                    saved_last_kill_tm = curr_tm;
                    check_med_emkill = true;
                }
                if ( check_med_emkill_count > 20 || (kill_timeout_ms == 0 ||
                    get_time_diff_ms(&last_kill_tm, &curr_tm) >= static_cast<long>(kill_timeout_ms))) {
                    check_med_emkill = false;
                    check_med_emkill_count = 0;
                }
            }
        } else {
            kill_timeout_ms = kill_timeout_ms_ori;
        }
    }

    if(use_emergency_kill) {   // Emergency Kill delay
        if (kill_pending && (kill_timeout_ms == 0 ||
            get_time_diff_ms(&last_kill_tm, &curr_tm) < static_cast<long>(kill_timeout_ms/10))) {
            /* Skip while still killing a process */
            kill_skip_count++;
            wi.skipped_wakeups++;
            goto no_kill;
        }
    } else {
        if ( ((use_bg_keeping_policy || use_bg_keeping_policy_light) && // Direct Reclaim Kill Booster , Critical Kill Booster
                (dr_killboost || (use_critical_kill_booster && level >= VMPRESS_LEVEL_CRITICAL && !psi_kill_keep_except))) ||
             (!use_bg_keeping_policy &&
                (dr_killboost || (use_critical_kill_booster && level >= VMPRESS_LEVEL_CRITICAL))) ){
            if (kill_pending && (kill_timeout_ms == 0 ||
                get_time_diff_ms(&last_kill_tm, &curr_tm) < static_cast<long>(kill_timeout_ms/5))) {
                /* Skip while still killing a process */
                kill_skip_count++;
                wi.skipped_wakeups++;
                goto no_kill;
            }
        } else {    // Normal Case
            if(check_med_emkill) {
                check_med_emkill_count++;
                // do nothing.
            } else if(use_killpending) {
                if (kill_pending && (kill_timeout_ms == 0 ||
                    get_time_diff_ms(&last_kill_tm, &curr_tm) < static_cast<long>(kill_timeout_ms))) {
                    /* Skip while still killing a process */
                    kill_skip_count++;
                    wi.skipped_wakeups++;
                    /* ULMK_LOG(D, "Ignoring %s pressure event; kill already in progress",
                    level_name[level]); */
                    goto no_kill;
                }
            } else {
                if ( (kill_timeout_ms == 0 ||
                    get_time_diff_ms(&last_kill_tm, &curr_tm) < static_cast<long>(kill_timeout_ms))) {
                    /* Skip while still killing a process */
                    kill_skip_count++;
                    wi.skipped_wakeups++;
                    goto no_kill;
                }
            }
        }
    }
    if(!use_killpending) use_killpending = true;
    /*
     * Process is dead or kill timeout is over, stop waiting. This has no effect if pidfds are
     * supported and death notification already caused waiting to stop.
     */
    stop_wait_for_proc_kill(!kill_pending);

    if (kill_skip_count > 0 || kill_skip_count_swap >= 50 || kill_skip_count_freelimit >= 50 ) {
        ALOGI("%lu(delay),%lu(swap), %lu(freelimit) memory pressure events were skipped after a kill!",
              kill_skip_count, kill_skip_count_swap,kill_skip_count_freelimit);
        kill_skip_count = 0;
        kill_skip_count_swap = 0;
        kill_skip_count_freelimit = 0;
    }

    if (vmstat_parse(&vs) < 0) {
        ALOGE("Failed to parse vmstat!");
        return;
    }
    /* Starting 5.9 kernel workingset_refault vmstat field was renamed workingset_refault_file */
    workingset_refault_file = vs.field.workingset_refault ? : vs.field.workingset_refault_file;

    if (meminfo_parse(&mi) < 0) {
        ALOGE("Failed to parse meminfo!");
        return;
    }

    if( check_model_trigger(&mi) ){
        swap_low_threshold = mi.field.total_swap * swap_free_low_percentage / 100;
    }

    if(!check_med_emkill) {

#ifdef LMKD_CHIMERA
    check_chimera_trigger_condition(&mi, &curr_tm, level, -1, -1);
#endif

    }

    /* Reset states after process got killed */
    if (killing) {
        killing = false;
        cycle_after_kill = true;
        /* Reset file-backed pagecache size and refault amounts after a kill */
        base_file_lru = vs.field.nr_inactive_file + vs.field.nr_active_file;
        init_ws_refault = workingset_refault_file;
        thrashing_reset_tm = curr_tm;
        prev_thrash_growth = 0;
    }

    if (debug_process_killing) {
        ULMK_LOG(D, "nr_free_pages: %" PRId64 " nr_inactive_file: %" PRId64
             " nr_active_file: %" PRId64  " workingset_refault: %" PRId64
             " pgscan_kswapd: %" PRId64 " pgscan_direct: %" PRId64
             " pgscan_direct_throttle: %" PRId64 " init_pgscan_direct: %" PRId64
             " init_pgscan_kswapd: %" PRId64 " base_file_lru: %" PRId64
             " init_ws_refault: %" PRId64 " free_swap: %" PRId64
             " total_swap: %" PRId64 " swap_free_percentage: %" PRId64 "%%",
             vs.field.nr_free_pages, vs.field.nr_inactive_file,
             vs.field.nr_active_file, vs.field.workingset_refault,
             vs.field.pgscan_kswapd, vs.field.pgscan_direct,
             vs.field.pgscan_direct_throttle, init_pgscan_direct,
             init_pgscan_kswapd, base_file_lru, init_ws_refault,
             mi.field.free_swap, mi.field.total_swap,
             (mi.field.free_swap * 100) / (mi.field.total_swap + 1));
    }
    if(use_qc_feature) {
        log_pgskip_stats(&vs, init_pgskip);
    }

    /* Check free swap levels */
    if (swap_free_low_percentage) {
        if (!swap_low_threshold) {
            swap_low_threshold = mi.field.total_swap * swap_free_low_percentage / 100;
        }
        swap_is_low = mi.field.free_swap < swap_low_threshold;
    }

    if(use_camera_boost){
        memboost = check_memboost();

        if(memboost == 2 && prev_memboost != memboost){
            last_boost_tm = curr_tm;
        }

        if(memboost == 2 && prev_memboost != memboost){
            //ALOGI("memboost set 2");
            last_boost_tm = curr_tm;
        } else if (memboost == 2 && prev_memboost == memboost && (get_time_diff_ms(&last_boost_tm, &curr_tm) > LAUNCHED_CAMERA_MEMBOOST_TIME_INKERNEL) ) {
            //ALOGI("memboost keep 2");
            last_boost_tm = curr_tm;
        }
        prev_memboost = memboost;

        if(get_time_diff_ms(&last_boost_tm, &curr_tm) <= LAUNCHED_CAMERA_MEMBOOST_TIME){
            swap_is_low = true;
        } else {
        }
    }
    if(use_camera_8k_boost){
        memboost = check_memboost();

        if(memboost == 3 && prev_8k_memboost != memboost){
            //ALOGI("memboost set 3");
            last_8k_boost_tm = curr_tm;
        } else if (memboost == 3 && prev_8k_memboost == memboost && (get_time_diff_ms(&last_8k_boost_tm, &curr_tm) > LAUNCHED_CAMERA_MEMBOOST_TIME_INKERNEL) ) {
            //ALOGI("memboost keep 3");
            last_8k_boost_tm = curr_tm;
        }
        prev_8k_memboost = memboost;

        if(get_time_diff_ms(&last_8k_boost_tm, &curr_tm) <= LAUNCHED_CAMERA_8K_MEMBOOST_TIME){
            swap_is_low = true;
            //ALOGI("trigger lmkd camera kill 8k_booster");
        } else {
        }
    }

    if (zoneinfo_parse_common(&zi) < 0) {
        ALOGE("Failed to parse zoneinfo!");
        return;
    }

    calc_zone_watermarks(&zi, &watermarks, &normal_watermarks, &nomovable_watermarks);
    totalreserve_pages = zi.totalreserve_pages;

    /* Find out which watermark is breached if any */
    wmark = custom_get_lowest_watermark(&mi, &watermarks);
    normal_wmark = zone_get_lowest_watermark(&mi, &normal_watermarks);
    nomovable_wmark = zone_get_lowest_watermark(&mi, &nomovable_watermarks);
    dr_killboost = false;

    temp_file_active_inactive = nomovable_watermarks.file_active_inactive;

    if( (normal_wmark <= WMARK_MINX2 && nomovable_wmark <= WMARK_LOW) || (is_movable_zone && nomovable_wmark <= WMARK_MINX2) ) {
        if(is_movable_zone) {
            if(temp_file_active_inactive <= low_cachemem_deadline_page_zone / 2) {
                use_emergency_kill = true;
                is_lowcachemem = true;
            } else {
                use_emergency_kill = false;
            }
        } else {
            if(temp_file_active_inactive <= low_cachemem_deadline_page_zone) {
                use_emergency_kill = true;
                is_lowcachemem = true;
            } else {
                use_emergency_kill = false;
            }
        }
    } else {
        use_emergency_kill = false;
    }

    if(wmark <= WMARK_LOW && temp_file_active_inactive <= low_cachemem_deadline_page_common) {
        swap_is_low = true;
    }

    other_file = 0;
    other_free = mi.field.nr_free_pages - totalreserve_pages;
    if(enable_cmarbinfree_sub){
         other_free = other_free - mi.field.cma_free - mi.field.free_rbin - mi.field.huge_page_pool;
    }
    if (mi.field.nr_file_pages > (mi.field.shmem + mi.field.unevictable + mi.field.swap_cached)) {
        other_file = (mi.field.nr_file_pages - mi.field.shmem -
                      mi.field.unevictable - mi.field.swap_cached);
        if(enable_cmarbinfree_sub){
            other_file = other_file - mi.field.cached_rbin;
        }
    } else {
        other_file = 0;
    }
    if (use_lowmem_keep_except) {
        int minfree = lowmem_minfree[MAX_TARGETS-1];
        if (other_free < minfree && other_file < minfree) {
            kill_keep_except = false;
        } else {
            kill_keep_except = true;
        }
    }

    if (!psi_parse_mem(&psi_data)) {
        bonus_limit = clamp(0, PAGE_200_MB, (psi_data.mem_stats[PSI_SOME].avg10 - PSI_10_AVG) * (multi_factor * PAGE_1_MB));
        if(psi_data.mem_stats[PSI_SOME].avg10 >= PSI_25_AVG) {
            //ALOGI("check PSI Some avg is over 25 : %f", psi_data.mem_stats[PSI_SOME].avg10);
            if(use_bg_keeping_policy) {
                origin_use_bg_keeping_policy = true;
                use_bg_keeping_policy = false;
                use_bg_keeping_policy_light = true;
            }
            if(!swap_is_low && origin_swap_free_low_percentage) {
                swap_is_low = mi.field.free_swap < mi.field.total_swap * origin_swap_free_low_percentage / 100;
            }
        } else {
            if(origin_use_bg_keeping_policy) {
                use_bg_keeping_policy = true;
                use_bg_keeping_policy_light = false;
            }
        }
    }

    if (other_file < lowmem_keep_except_limit_val + bonus_limit) {
        psi_kill_keep_except = false;
        if(other_file < lowmem_keep_except_limit_val) dr_kill_boost_upgrade_th = true;
    } else {
        psi_kill_keep_except = true;
        dr_kill_boost_upgrade_th = false;
    }

    if(!use_camera_kill_mode_light && use_camera_kill_mode && cameramode_killboost) {
        //ALOGI("check kill booster on %" PRId64 " , %" PRId64 " ", low_pressure_mem.zoneinfo_min_pages, mi.field.nr_free_pages);
        if(!swap_is_low) {
            if(level > VMPRESS_LEVEL_MEDIUM) {
                if (swap_free_low_percentage <= 15) {
                    swap_is_low = mi.field.free_swap < (swap_low_threshold * 2);
                } else if (swap_free_low_percentage < 30) {
                    swap_is_low = mi.field.free_swap < (mi.field.total_swap * 30 / 100);
                }
            }
            if(other_file < lowmem_keep_except_limit_val * 1.1) {
                swap_is_low = mi.field.free_swap < (mi.field.total_swap * 50 / 100);
            }
        }
        // cachemem is lower than 300MB
        if(wmark <= WMARK_MINX2 && mi.field.cached <= low_cachemem_deadline_page) {
            use_emergency_kill = true;
        }
    }

    if(use_qc_feature) { // QC Code
        if (vs.field.compact_stall > init_compact_stall) {
            init_compact_stall = vs.field.compact_stall;
            in_compaction = true;
        }
    }

    if (use_emergency_kill) {
        reclaim = EMERGENCY_MEM;
        swap_is_low = true;
        if(level == VMPRESS_LEVEL_MEDIUM) {
            level = upgrade_level(level);
        }
    }

    /* Identify reclaim state */
    if (vs.field.pgscan_direct > init_pgscan_direct) {
        init_pgscan_direct = vs.field.pgscan_direct;
        init_pgscan_kswapd = vs.field.pgscan_kswapd;
        reclaim = DIRECT_RECLAIM;

        if(use_dr_kill_boost && wmark <= WMARK_MINX2) {
            dr_killboost = true;
        }
        if(use_qc_feature) {
            for (i = VS_PGSKIP_FIRST_ZONE; i <= VS_PGSKIP_LAST_ZONE; i++) {
                init_pgskip[PGSKIP_IDX(i)] = vs.arr[i];
            }
        }
    } else if (use_dr_kill_boost && wmark <= WMARK_MINX2) {  // samsung code
        init_pgscan_direct = vs.field.pgscan_direct;
        init_pgscan_kswapd = vs.field.pgscan_kswapd;
        reclaim = DIRECT_RECLAIM_CUSTOM;

        dr_killboost = true;

        if(use_qc_feature) {
            for (i = VS_PGSKIP_FIRST_ZONE; i <= VS_PGSKIP_LAST_ZONE; i++) {
                init_pgskip[PGSKIP_IDX(i)] = vs.arr[i];
            }
        }
    } else if (vs.field.pgscan_kswapd > init_pgscan_kswapd) {
        init_pgscan_kswapd = vs.field.pgscan_kswapd;
        reclaim = KSWAPD_RECLAIM;

        if(use_qc_feature) {
            for (i = VS_PGSKIP_FIRST_ZONE; i <= VS_PGSKIP_LAST_ZONE; i++) {
                init_pgskip[PGSKIP_IDX(i)] = vs.arr[i];
            }
        }
    } else if (wmark <= WMARK_LOW){ // samsung code
        init_pgscan_kswapd = vs.field.pgscan_kswapd;
        reclaim = KSWAPD_RECLAIM_CUSTOM;

        if(use_qc_feature) {
            for (i = VS_PGSKIP_FIRST_ZONE; i <= VS_PGSKIP_LAST_ZONE; i++) {
                init_pgskip[PGSKIP_IDX(i)] = vs.arr[i];
            }
        }
    } else if (workingset_refault_file == prev_workingset_refault) {
        /*
         * Device is not thrashing and not reclaiming, bail out early until we see these stats
         * changing
         */
        if(use_qc_feature) {
            /*
            if (enable_preferred_apps &&
                      (get_time_diff_ms(&last_pa_update_tm, &curr_tm) >= pa_update_timeout_ms)) {
                  perf_ux_engine_trigger(PAPP_OPCODE, preferred_apps);
                  last_pa_update_tm = curr_tm;
            }
            */
            if (!in_compaction) {
                /* Skip if system is not reclaiming */
                ULMK_LOG(D, "Ignoring %s pressure event; system is not in reclaim",
                         level_name[level]);
                goto no_kill;
            }
        } else {
            goto no_kill;
        }
    }

    if(check_med_emkill) {
        goto no_kill;
    }

    prev_workingset_refault = workingset_refault_file;

     /*
     * It's possible we fail to find an eligible process to kill (ex. no process is
     * above oom_adj_min). When this happens, we should retry to find a new process
     * for a kill whenever a new eligible process is available. This is especially
     * important for a slow growing refault case. While retrying, we should keep
     * monitoring new thrashing counter as someone could release the memory to mitigate
     * the thrashing. Thus, when thrashing reset window comes, we decay the prev thrashing
     * counter by window counts. If the counter is still greater than thrashing limit,
     * we preserve the current prev_thrash counter so we will retry kill again. Otherwise,
     * we reset the prev_thrash counter so we will stop retrying.
     */
    since_thrashing_reset_ms = get_time_diff_ms(&thrashing_reset_tm, &curr_tm);
    if (since_thrashing_reset_ms > THRASHING_RESET_INTERVAL_MS) {
        long windows_passed;
        /* Calculate prev_thrash_growth if we crossed THRASHING_RESET_INTERVAL_MS */
        prev_thrash_growth = (workingset_refault_file - init_ws_refault) * 100
                            / (base_file_lru + 1);
        windows_passed = (since_thrashing_reset_ms / THRASHING_RESET_INTERVAL_MS);
        /*
         * Decay prev_thrashing unless over-the-limit thrashing was registered in the window we
         * just crossed, which means there were no eligible processes to kill. We preserve the
         * counter in that case to ensure a kill if a new eligible process appears.
         */
        if (windows_passed > 1 || prev_thrash_growth < thrashing_limit) {
            prev_thrash_growth >>= windows_passed;
        }

        /* Record file-backed pagecache size when crossing THRASHING_RESET_INTERVAL_MS */
        base_file_lru = vs.field.nr_inactive_file + vs.field.nr_active_file;
        init_ws_refault = workingset_refault_file;
        thrashing_reset_tm = curr_tm;
        thrashing_limit = thrashing_limit_pct;
    } else {
        /* Calculate what % of the file-backed pagecache refaulted so far */
        thrashing = (workingset_refault_file - init_ws_refault) * 100 / (base_file_lru + 1);
        /* ULMK_LOG(D, "thrashing: %" PRId64 "%% thrashing_limit: %d%%", thrashing,
                 thrashing_limit); */
    }
    /* Add previous cycle's decayed thrashing amount */
    thrashing += prev_thrash_growth;
    if (max_thrashing < thrashing) {
        max_thrashing = thrashing;
    }

    if (dr_killboost) {
        if (!use_light_dr_killbooster || thrashing > thrashing_limit / 3) {
            swap_is_low = true;
        }

        if(!use_bg_keeping_policy || is_lowcachemem) {
            if(dr_kill_boost_upgrade_th && level == VMPRESS_LEVEL_MEDIUM) {
                level = upgrade_level(level);
            }
        }
    }

    /*
     * Refresh watermarks once per min in case user updated one of the margins.
     * TODO: b/140521024 replace this periodic update with an API for AMS to notify LMKD
     * that zone watermarks were changed by the system software.
     */

    /* AOSP Code
    if (watermarks.high_wmark == 0 || get_time_diff_ms(&wmark_update_tm, &curr_tm) > 60000) {
        struct zoneinfo zi;

        if (zoneinfo_parse_common(&zi) < 0) {
            ALOGE("Failed to parse zoneinfo!");
            return;
        }

        calc_zone_watermarks(&zi, &watermarks);
        wmark_update_tm = curr_tm;
    }
    */

    /* Find out which watermark is breached if any */
    //wmark = get_lowest_watermark(&mi, &watermarks);
    //wmark = custom_get_lowest_watermark(&mi, &watermarks);

    if(use_qc_feature) {
        log_meminfo(&mi, wmark);
    }

    /*
     * TODO: move this logic into a separate function
     * Decide if killing a process is necessary and record the reason
     */
    if (cycle_after_kill && wmark < WMARK_LOW) { // WMARK_MIN and WMARK_MINX2
        /*
         * Prevent kills not freeing enough memory which might lead to OOM kill.
         * This might happen when a process is consuming memory faster than reclaim can
         * free even after a kill. Mostly happens when running memory stress tests.
         */
        kill_reason = PRESSURE_AFTER_KILL;
        if(wmark == WMARK_MINX2) kill_reason = PRESSURE_AFTER_KILL_DRKILL; // Direct Reclaim Kill Booster
        //strncpy(kill_desc, "min watermark is breached even after kill", sizeof(kill_desc));
        snprintf(kill_desc, sizeof(kill_desc), "%s watermark is breached even after kill", wmark < WMARK_MINX2 ? "min" : "min2x");
    } else if (level == VMPRESS_LEVEL_SUPER_CRITICAL && events != 0) {
        /*
         * Device is too busy reclaiming memory which might lead to ANR.
         * Critical level is triggered when PSI complete stall (all tasks are blocked because
         * of the memory congestion) breaches the configured threshold.
         */
        kill_reason = NOT_RESPONDING;
        strlcpy(kill_desc, "device is not responding", sizeof(kill_desc));
    } else if (swap_is_low && thrashing > thrashing_limit_pct) {
        /* Page cache is thrashing while swap is low */
        kill_reason = LOW_SWAP_AND_THRASHING;
        snprintf(kill_desc, sizeof(kill_desc), "device is low on swap (%" PRId64
            "kB < %" PRId64 "kB) and thrashing (%" PRId64 "%%)",
            mi.field.free_swap * page_k, swap_low_threshold * page_k, thrashing);
        /* Do not kill perceptible apps unless below min watermark or heavily thrashing */
        if (wmark > WMARK_MIN && thrashing < thrashing_critical_pct) {
            min_score_adj = PERCEPTIBLE_APP_ADJ + 1;
        }
        check_filecache = true;
    } else if (swap_is_low && wmark < WMARK_HIGH) {
        /* Both free memory and swap are low */
        kill_reason = LOW_MEM_AND_SWAP;
        snprintf(kill_desc, sizeof(kill_desc), "%s watermark is breached and swap is low (%"
            PRId64 "kB < %" PRId64 "kB)", wmark < WMARK_MINX2 ? "min" : wmark < WMARK_LOW ? "min2x" : "low",
            mi.field.free_swap * page_k, swap_low_threshold * page_k);
        /* Do not kill perceptible apps unless below min watermark or heavily thrashing */
        if (wmark > WMARK_MIN && thrashing < thrashing_critical_pct) {
            min_score_adj = PERCEPTIBLE_APP_ADJ + 1;
        }
        if (wmark > WMARK_MIN) {
            if (level == VMPRESS_LEVEL_MEDIUM) {
                min_score_adj = level_oomadj[level]; // MEDIUM PRESSURE ADJ 850
            }
        }
    } else if (wmark < WMARK_HIGH && swap_util_max < 100 &&
               (swap_util = calc_swap_utilization(&mi)) > swap_util_max) {
        /*
         * Too much anon memory is swapped out but swap is not low.
         * Non-swappable allocations created memory pressure.
         */
        kill_reason = LOW_MEM_AND_SWAP_UTIL;
        snprintf(kill_desc, sizeof(kill_desc), "%s watermark is breached and swap utilization"
            " is high (%d%% > %d%%)", wmark < WMARK_MINX2 ? "min" : wmark < WMARK_LOW ? "min2x" : "low",
            swap_util, swap_util_max);
    } else if (wmark < WMARK_HIGH && thrashing > thrashing_limit) {
        /* Page cache is thrashing while memory is low */
        kill_reason = LOW_MEM_AND_THRASHING;
        snprintf(kill_desc, sizeof(kill_desc), "%s watermark is breached and thrashing (%"
            PRId64 "%%)", wmark < WMARK_MINX2 ? "min" : wmark < WMARK_LOW ? "min2x" : "low", thrashing);
        cut_thrashing_limit = true;
        /* Do not kill perceptible apps unless thrashing at critical levels */
        if (thrashing < thrashing_critical_pct) {
            min_score_adj = PERCEPTIBLE_APP_ADJ + 1;
        }
        check_filecache = true;
    } else if (reclaim == DIRECT_RECLAIM && thrashing > thrashing_limit) {
        /* Page cache is thrashing while in direct reclaim (mostly happens on lowram devices) */
        kill_reason = DIRECT_RECL_AND_THRASHING;
        snprintf(kill_desc, sizeof(kill_desc), "device is in direct reclaim and thrashing (%"
            PRId64 "%%)", thrashing);
        cut_thrashing_limit = true;
        /* Do not kill perceptible apps unless thrashing at critical levels */
        if (thrashing < thrashing_critical_pct) {
            min_score_adj = PERCEPTIBLE_APP_ADJ + 1;
        }
        check_filecache = true;
    } else if (check_filecache) {
        int64_t file_lru_kb = (vs.field.nr_inactive_file + vs.field.nr_active_file) * page_k;

        if (file_lru_kb < filecache_min_kb) {
            /* File cache is too low after thrashing, keep killing background processes */
            kill_reason = LOW_FILECACHE_AFTER_THRASHING;
            snprintf(kill_desc, sizeof(kill_desc),
                "filecache is low (%" PRId64 "kB < %" PRId64 "kB) after thrashing",
                file_lru_kb, filecache_min_kb);
            min_score_adj = PERCEPTIBLE_APP_ADJ + 1;
        } else {
            /* File cache is big enough, stop checking */
            check_filecache = false;
        }
    } else if (reclaim == EMERGENCY_MEM) {
        if(is_lowcachemem) {
            kill_reason = EMERGENCY_KILL_LOWCACHE;
            strncpy(kill_desc, "device under emergency mem (lowcache)", sizeof(kill_desc));
        } else {
            kill_reason = EMERGENCY_KILL;
            strncpy(kill_desc, "device under emergency mem", sizeof(kill_desc));
        }

        min_score_adj = min_score_adj == 0 ? 0 : 1;
    }/* else if (in_compaction && wmark <= WMARK_HIGH) {
        kill_reason = COMPACTION;
        strncpy(kill_desc, "device is in compaction and low on memory", sizeof(kill_desc));
        min_score_adj = VISIBLE_APP_ADJ;
    } QC Code*/

    if (use_bg_keeping_policy || use_bg_keeping_policy_light) {
        if (use_emergency_kill) {
            min_score_adj = min_score_adj == 0 ? 0 : 1;
            if(is_lowcachemem) {
                kill_reason = EMERGENCY_KILL_LOWCACHE;
            } else {
                kill_reason = EMERGENCY_KILL;
            }
        } else if (level == VMPRESS_LEVEL_MEDIUM) {
            if(psi_kill_keep_except) {
                //if(wmark > WMARK_MIN)
                min_score_adj = level_oomadj[level]; // MEDIUM PRESSURE ADJ 850
            } else {
                min_score_adj = min_score_adj < 701 ? min_score_adj : 701;
            }
        } else if (level == VMPRESS_LEVEL_CRITICAL) {
            if(psi_kill_keep_except && !cameramode_killboost && thrashing < thrashing_limit/2) {
                min_score_adj = level_oomadj[VMPRESS_LEVEL_MEDIUM]; // downgrade to medium kill adj
                level = VMPRESS_LEVEL_MEDIUM;
            }
        }
    } else {
        if (use_emergency_kill) {
            min_score_adj = min_score_adj == 0 ? 0 : 1;
            if(is_lowcachemem) {
                kill_reason = EMERGENCY_KILL_LOWCACHE;
            } else {
                kill_reason = EMERGENCY_KILL;
            }
        } else if (psi_kill_keep_except && level == VMPRESS_LEVEL_MEDIUM) {
            if(wmark > WMARK_MIN)
                min_score_adj = level_oomadj[level]; // MEDIUM PRESSURE ADJ 850
        }
    }
    /* Kill a process if necessary */
    if (kill_reason != NONE) {
        struct kill_info ki = {
            .kill_reason = kill_reason,
            .kill_desc = kill_desc,
            .thrashing = (int)thrashing,
            .max_thrashing = max_thrashing,
        };
        int pages_freed = find_and_kill_process(min_score_adj, &ki, &mi, &wi, &curr_tm, level);
        if (pages_freed > 0) {
            killing = true;
            max_thrashing = 0;
            if (cut_thrashing_limit) {
                /*
                 * Cut thrasing limit by thrashing_limit_decay_pct percentage of the current
                 * thrashing limit until the system stops thrashing.
                 */
                thrashing_limit = (thrashing_limit * (100 - thrashing_limit_decay_pct)) / 100;
            }
            kill_skip_count = kill_skip_count_swap = kill_skip_count_freelimit = 0;
        } else {
            //ULMK_LOG(D, "No processes to kill with adj score >= %d",
            //         min_score_adj);

            if (level == VMPRESS_LEVEL_MEDIUM && pages_freed == 0) { // if there is no process killed, then init kill delay. for reducing unnecessary operation.
                last_kill_tm = curr_tm;
                saved_last_kill_tm = last_kill_tm;
                use_killpending = false;
            }
        }
    } else {
        //ULMK_LOG(D, "Not killing for %s pressure event %s", level_name[level],
        //         events ? "trigger" : "polling check");

        if(wmark == WMARK_NONE){
            kill_skip_count_freelimit++;
        } else if (wmark < WMARK_HIGH){
            kill_skip_count_swap++;
        }
    }

no_kill:
    /* Do not poll if kernel supports pidfd waiting */
    if (is_waiting_for_kill()) {
        /* Pause polling if we are waiting for process death notification */
        poll_params->update = POLLING_PAUSE;
        return;
    }

    /*
     * Start polling after initial PSI event;
     * extend polling while device is in direct reclaim or process is being killed;
     * do not extend when kswapd reclaims because that might go on for a long time
     * without causing memory pressure
     */
    if (events || killing || reclaim == DIRECT_RECLAIM || reclaim == DIRECT_RECLAIM_CUSTOM) {
        poll_params->update = POLLING_START;
    }

    /* Decide the polling interval */
    if (swap_is_low || killing) {
        /* Fast polling during and after a kill or when swap is low */
        poll_params->polling_interval_ms = PSI_POLL_PERIOD_SHORT_MS;
    } else {
        /* By default use long intervals */
        poll_params->polling_interval_ms = PSI_POLL_PERIOD_LONG_MS;
    }
}

enum vmpressure_level upgrade_vmpressure_event(enum vmpressure_level level)
{
    static union vmstat base;
    union vmstat current;
    int64_t throttle, pressure;
    static int64_t sync, async;

    switch (level) {
        case VMPRESS_LEVEL_LOW:
            if (vmstat_parse(&base) < 0) {
                ULMK_LOG(E, "Failed to parse vmstat!");
                goto out;
            }
            break;
        case VMPRESS_LEVEL_MEDIUM:
        case VMPRESS_LEVEL_CRITICAL:
            if (vmstat_parse(&current) < 0) {
                ULMK_LOG(E, "Failed to parse vmstat!");
                goto out;
            }
            throttle = current.field.pgscan_direct_throttle -
                    base.field.pgscan_direct_throttle;
	    sync += (current.field.pgscan_direct -
		     base.field.pgscan_direct);
	    async += (current.field.pgscan_kswapd -
		      base.field.pgscan_kswapd);
	    /* Here scan window size is put at default 4MB(=1024 pages). */
	    if (throttle || (sync + async) >= reclaim_scan_threshold) {
		    pressure = ((100 * sync)/(sync + async + 1));
		    if (throttle || (pressure >= direct_reclaim_pressure)) {
			    last_event_upgraded = true;
			    if (count_upgraded_event >= 4) {
				    count_upgraded_event = 0;
				    s_crit_event = true;
				    if (debug_process_killing)
					    ULMK_LOG(D, "Medium/Critical is permanently upgraded to Supercritical event\n");
			    } else {
				    s_crit_event = s_crit_event_upgraded = true;
				    if (debug_process_killing)
					    ULMK_LOG(D, "Medium/Critical is upgraded to Supercritical event\n");
			    }
			    s_crit_base = current;
		    }
		    sync = async = 0;
            }
            base = current;
            break;
        default:
            ;
    }
out:
    return level;
}

static void mp_event_common(int data, uint32_t events, struct polling_params *poll_params) {
    unsigned long long evcount;
    int64_t mem_usage, memsw_usage;
    int64_t mem_pressure;
    union meminfo mi;
    struct zoneinfo zi;
    union vmstat s_crit_current;
    struct timespec curr_tm;
    //static struct timespec last_pa_update_tm; /* SystemSW2G SystemHealth, we do not use this code because we don't use perfd */
    static unsigned long kill_skip_count = 0, kill_skip_count_swap = 0, kill_skip_count_freelimit = 0;
    enum vmpressure_level level = (enum vmpressure_level)data;
    long other_free = 0, other_file = 0;
    int min_score_adj;
    int minfree = 0;
    int memboost=0;

    static struct reread_data mem_usage_file_data = {
        .filename = MEMCG_MEMORY_USAGE,
        .fd = -1,
    };
    static struct reread_data memsw_usage_file_data = {
        .filename = MEMCG_MEMORYSW_USAGE,
        .fd = -1,
    };
    static struct wakeup_info wi;

    if(use_qc_feature) {
        if (!s_crit_event)
            level = upgrade_vmpressure_event(level);
    }

    if (debug_process_killing) {
        ALOGI("%s memory pressure event is triggered", level_name[level]);
    }

    if (!use_psi_monitors) {
        /*
         * Check all event counters from low to critical
         * and upgrade to the highest priority one. By reading
         * eventfd we also reset the event counters.
         */
        for (int lvl = VMPRESS_LEVEL_LOW; lvl < VMPRESS_LEVEL_COUNT; lvl++) {
            if (mpevfd[lvl] != -1 &&
                TEMP_FAILURE_RETRY(read(mpevfd[lvl],
                                   &evcount, sizeof(evcount))) > 0 &&
                evcount > 0 && lvl > level) {
                level = static_cast<vmpressure_level>(lvl);
            }
        }
    }

    /* Start polling after initial PSI event */
    if (use_psi_monitors && events) {
        /* Override polling params only if current event is more critical */
        if (!poll_params->poll_handler || data > poll_params->poll_handler->data) {
            poll_params->polling_interval_ms = PSI_POLL_PERIOD_SHORT_MS;
            poll_params->update = POLLING_START;
        }
        if (use_qc_feature) { // QC code
            /*
             * Nonzero events indicates handler call due to recieved epoll_event,
             * rather than due to epoll_event timeout.
             */
            if (events) {
                if (data == VMPRESS_LEVEL_SUPER_CRITICAL) {
                    s_crit_event = true;
            poll_params->polling_interval_ms = psi_poll_period_scrit_ms;
                    vmstat_parse(&s_crit_base);
                }
                else if (s_crit_event) {
                    /* Override the supercritical event only if the system
                     * is not in direct reclaim.
                     */
                    int64_t throttle, sync;

                    vmstat_parse(&s_crit_current);
                    throttle = s_crit_current.field.pgscan_direct_throttle -
                                s_crit_base.field.pgscan_direct_throttle;
                    sync = s_crit_current.field.pgscan_direct -
                            s_crit_base.field.pgscan_direct;
                    if (!throttle && !sync)
                        s_crit_event = false;
                    s_crit_base = s_crit_current;
                }
            }
        }
    }

    if (clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm) != 0) {
        ALOGE("Failed to get current time");
        return;
    }

    record_wakeup_time(&curr_tm, events ? Event : Polling, &wi);

    if (dr_killboost || (use_critical_kill_booster && level >= VMPRESS_LEVEL_CRITICAL)){
        if (kill_timeout_ms &&
            get_time_diff_ms(&last_kill_tm, &curr_tm) < static_cast<long>(kill_timeout_ms/5)) {
            if (is_kill_pending()) {
                kill_skip_count++;
                wi.skipped_wakeups++;
                return;
            }
            stop_wait_for_proc_kill(true);
        } else {
            /*
             * Killing took longer than no-kill timeout. Stop waiting for the last process
             * to die because we are ready to kill again.
             */
            stop_wait_for_proc_kill(false);
        }
    } else {
        if (kill_timeout_ms &&
            get_time_diff_ms(&last_kill_tm, &curr_tm) < static_cast<long>(kill_timeout_ms)) {
            /*
             * If we're within the no-kill timeout, see if there's pending reclaim work
             * from the last killed process. If so, skip killing for now.
             */
            if (is_kill_pending()) {
                kill_skip_count++;
                wi.skipped_wakeups++;
                return;
            }
            /*
             * Process is dead, stop waiting. This has no effect if pidfds are supported and
             * death notification already caused waiting to stop.
             */
            stop_wait_for_proc_kill(true);
        } else {
            /*
             * Killing took longer than no-kill timeout. Stop waiting for the last process
             * to die because we are ready to kill again.
             */
            stop_wait_for_proc_kill(false);
        }
    }

    if (kill_skip_count > 0 || kill_skip_count_swap >= 50 || kill_skip_count_freelimit >= 50 ) {
        ALOGI("%lu(delay),%lu(swap), %lu(freelimit) memory pressure events were skipped after a kill!",
              kill_skip_count, kill_skip_count_swap,kill_skip_count_freelimit);
        kill_skip_count = 0;
        kill_skip_count_swap = 0;
        kill_skip_count_freelimit = 0;
    }

    if (meminfo_parse(&mi) < 0 || zoneinfo_parse_common(&zi) < 0) {
        ALOGE("Failed to get free memory!");
        return;
    }

    check_model_trigger(&mi);

    if(enable_cmarbinfree_sub){
        mi.field.nr_free_pages = mi.field.nr_free_pages - mi.field.free_rbin;  // meminfo
        mi.field.nr_free_pages = mi.field.nr_free_pages - mi.field.cma_free;  // meminfo
        mi.field.nr_free_pages = mi.field.nr_free_pages - mi.field.huge_page_pool;  // meminfo
        if(mi.field.free_rbin == 0){
            mi.field.nr_free_pages = mi.field.nr_free_pages - zi.total_nr_free_rbin;  // zoneinfo
        }
        if(mi.field.cma_free == 0){
            mi.field.nr_free_pages = mi.field.nr_free_pages - zi.total_nr_free_cma;  // zoneinfo
        }
    }

    {
        other_free = mi.field.nr_free_pages - zi.totalreserve_pages;
        if (mi.field.nr_file_pages > (mi.field.shmem + mi.field.unevictable + mi.field.swap_cached)) {
            other_file = (mi.field.nr_file_pages - mi.field.shmem -
                          mi.field.unevictable - mi.field.swap_cached);
            if(enable_cmarbinfree_sub){
                other_file = other_file - mi.field.cached_rbin;
            }
        } else {
            other_file = 0;
        }

        if(!use_minfree_levels && use_lowmem_keep_except) {
            minfree = lowmem_minfree[MAX_TARGETS-1];
            if (other_free < minfree && other_file < minfree) {
                kill_keep_except = false;
            } else {
                kill_keep_except = true;
            }
        }
        if (!use_minfree_levels && other_file < lowmem_keep_except_limit_val) {
            psi_kill_keep_except = false;
        } else {
            psi_kill_keep_except = true;
        }
    }
    if (use_minfree_levels) {
        int i;

        min_score_adj = OOM_SCORE_ADJ_MAX + 1;
        for (i = 0; i < lowmem_targets_size; i++) {
            minfree = lowmem_minfree[i];
            if (other_free < minfree && other_file < minfree) {
                min_score_adj = lowmem_adj[i];
                // Adaptive LMK
                if (enable_adaptive_lmk && level == VMPRESS_LEVEL_CRITICAL &&
                        i > lowmem_targets_size-4) {
                    min_score_adj = lowmem_adj[i-1];
                }
                break;
            }
        }

        if (min_score_adj == OOM_SCORE_ADJ_MAX + 1) {
            if (debug_process_killing) {
                ALOGI("Ignore %s memory pressure event "
                      "(free memory=%ldkB, cache=%ldkB, limit=%ldkB)",
                      level_name[level], other_free * page_k, other_file * page_k,
                      (long)lowmem_minfree[lowmem_targets_size - 1] * page_k);
            }
            return;
        }

        goto do_kill;
    }

    if(lmkd_freelimit_enable){
        low_pressure_mem.max_nr_free_pages = (int64_t)( zi.total_low * (lmkd_freelimit_val / 10.0) );
        low_pressure_mem.low_adj_max_nr_free_pages = (int64_t)( zi.total_low * 0.6 );
        low_pressure_mem.zoneinfo_min_pages = (int64_t)( zi.total_min * 2.0 );
        if(low_pressure_mem.zoneinfo_min_pages - zi.total_min > 2560) low_pressure_mem.zoneinfo_min_pages = zi.total_min + 2560;
        result_freelimit_val = low_pressure_mem.max_nr_free_pages;
    } else {
        if (level == VMPRESS_LEVEL_LOW) {
            record_low_pressure_levels(&mi);
            /* SystemSW2G SystemHealth, we do not use this code because we don't use perfd
            if (enable_preferred_apps) {
                if (get_time_diff_ms(&last_pa_update_tm, &curr_tm) >= pa_update_timeout_ms) {
                    perf_ux_engine_trigger(PAPP_OPCODE, preferred_apps);
                    last_pa_update_tm = curr_tm;
                }
            }
            */
        }
    }

    if (level_oomadj[level] > OOM_SCORE_ADJ_MAX) {
        /* Do not monitor this pressure level */
        return;
    }

    if ((mem_usage = get_memory_usage(&mem_usage_file_data)) < 0) {
        goto do_kill;
    }
    if ((memsw_usage = get_memory_usage(&memsw_usage_file_data)) < 0) {
        goto do_kill;
    }

    // Calculate percent for swappinness.
    mem_pressure = (mem_usage * 100) / memsw_usage;
    if(mem_pressure > 100) mem_pressure = 100;

    if(use_camera_boost){
        memboost = check_memboost();

        if(memboost == 2 && prev_memboost != memboost){
            last_boost_tm = curr_tm;
        }
        prev_memboost = memboost;

        if(get_time_diff_ms(&last_boost_tm, &curr_tm) <= LAUNCHED_CAMERA_MEMBOOST_TIME){
            mem_pressure = 0;
        } else {
        }
    }
    if(use_camera_8k_boost){
        memboost = check_memboost();

        if(memboost == 3 && prev_8k_memboost != memboost){
            //ALOGI("memboost set 3");
            last_8k_boost_tm = curr_tm;
        } else if (memboost == 3 && prev_8k_memboost == memboost && (get_time_diff_ms(&last_8k_boost_tm, &curr_tm) > LAUNCHED_CAMERA_MEMBOOST_TIME_INKERNEL) ) {
            //ALOGI("memboost keep 3");
            last_8k_boost_tm = curr_tm;
        }
        prev_8k_memboost = memboost;

        if(get_time_diff_ms(&last_8k_boost_tm, &curr_tm) <= LAUNCHED_CAMERA_8K_MEMBOOST_TIME){
            mem_pressure = 0;
            //ALOGI("trigger lmkd camera kill 8k_booster");
        } else {
        }
    }

    if (!use_minfree_levels) {
        if (!enable_watermark_check) {
            if(use_dr_kill_boost && (mi.field.nr_free_pages <= low_pressure_mem.zoneinfo_min_pages) ){
                dr_killboost=true;
                if(use_light_dr_killbooster) {
                    if(level == VMPRESS_LEVEL_MEDIUM)
                        mem_pressure = 0;
                } else {
                    mem_pressure = 0;
                }
                if(!psi_kill_keep_except && level == VMPRESS_LEVEL_MEDIUM) level = upgrade_level(level);
            } else {
                dr_killboost=false;
            }
        }
    }

    if (enable_pressure_upgrade && level != VMPRESS_LEVEL_CRITICAL) {
        // We are swapping too much.
        if (mem_pressure < upgrade_pressure) {
            level = upgrade_level(level);
            if (debug_process_killing) {
                ALOGI("Event upgraded to %s", level_name[level]);
            }
        }
    }
#ifdef LMKD_CHIMERA
    check_chimera_trigger_condition(&mi, &curr_tm, level, minfree, mem_pressure);
#endif

    // If we still have enough swap space available, check if we want to
    // ignore/downgrade pressure events.
    if (mi.field.total_swap && (mi.field.free_swap >=
        mi.field.total_swap * swap_free_low_percentage / 100)) {
        // If the pressure is larger than downgrade_pressure lmk will not
        // kill any process, since enough memory is available.
        if (level < VMPRESS_LEVEL_CRITICAL && mem_pressure > downgrade_pressure) {
            if (debug_process_killing) {
                ALOGI("Ignore %s memory pressure", level_name[level]);
            }
            kill_skip_count_swap++;
            return;
        } else if (level == VMPRESS_LEVEL_CRITICAL && mem_pressure > upgrade_pressure) {
            if (debug_process_killing) {
                ALOGI("Downgrade critical memory pressure");
            }
            // Downgrade event, since enough memory available.
            level = downgrade_level(level);
        }
    }

do_kill:
    if (low_ram_device && per_app_memcg) {
        /* For Go devices kill only one task */
        if (find_and_kill_process(level_oomadj[level], NULL, &mi, &wi, &curr_tm, level) == 0) {
            if (debug_process_killing) {
                ALOGI("Nothing to kill");
            }
        }
    } else {
        long pages_freed;
        static struct timespec last_report_tm;
        static unsigned long report_skip_count = 0;

        if (!use_minfree_levels) {
            if (!enable_watermark_check) {
                /* Free up enough memory to downgrate the memory pressure to low level */
                if (mi.field.nr_free_pages >= low_pressure_mem.max_nr_free_pages) {
                    if (debug_process_killing) {
                        ULMK_LOG(I, "Ignoring pressure since more memory is "
                            "available (%" PRId64 ") than watermark (%" PRId64 ")",
                            mi.field.nr_free_pages, low_pressure_mem.max_nr_free_pages);
                    }
                    kill_skip_count_freelimit++;
                    return;
                } else if (mi.field.nr_free_pages >= low_pressure_mem.low_adj_max_nr_free_pages) {
                    low_adj_kill_skip = true && kill_keep_except;
                } else {
                    low_adj_kill_skip = false;
                }
                min_score_adj = level_oomadj[level];
            } else {
                min_score_adj = zone_watermarks_ok(level);
                if (min_score_adj == OOM_SCORE_ADJ_MAX + 1)
                {
                    ULMK_LOG(I, "Ignoring pressure since per-zone watermarks ok");
                    return;
                }
            }
        }

        pages_freed = find_and_kill_process(min_score_adj, NULL, &mi, &wi, &curr_tm, level);

        if(pages_freed == KILL_SKIPPED){
            kill_skip_count_freelimit++;
            return;
        }

        if (pages_freed == 0) {
            /* Rate limit kill reports when nothing was reclaimed */
            if (get_time_diff_ms(&last_report_tm, &curr_tm) < FAIL_REPORT_RLIMIT_MS) {
                report_skip_count++;
                return;
            }
        } else {
            kill_skip_count = 0;
            kill_skip_count_swap = 0;
            kill_skip_count_freelimit = 0;
        }

        /* Log whenever we kill or when report rate limit allows */
        if (use_minfree_levels) {
            ALOGI("Reclaimed %ldkB, cache(%ldkB) and free(%" PRId64 "kB)-reserved(%" PRId64 "kB) "
                "below min(%ldkB) for oom_score_adj %d",
                pages_freed * page_k,
                other_file * page_k, mi.field.nr_free_pages * page_k,
                zi.totalreserve_pages * page_k,
                minfree * page_k, min_score_adj);
        } else {
            ALOGI("Reclaimed %ldkB at oom_score_adj %d", pages_freed * page_k, min_score_adj);
        }

        if (report_skip_count > 0) {
            ALOGI("Suppressed %lu failed kill reports", report_skip_count);
            report_skip_count = 0;
        }

        last_report_tm = curr_tm;
    }
    if (is_waiting_for_kill()) {
        /* pause polling if we are waiting for process death notification */
        poll_params->update = POLLING_PAUSE;
    }
}

static bool check_model_trigger(union meminfo *mi) {
    bool is_success=false;
    if (!is_check_model_name && mi->field.total_swap > 0) {
        ALOGD("trigger check_model_name");
        is_check_model_name = true;
        is_success = check_model_name(mi);
    }
    return is_success;
}

static bool check_model_name(union meminfo *mi) {
    int prev_swap_free_low_percentage = swap_free_low_percentage;
    int64_t base_swaptotal_kb;
    int64_t cur_swaptotal_kb;
    int64_t cur_memtotal_kb;
    int64_t target_swaptotal_kb;

    char swapfreelow_str[PROPERTY_VALUE_MAX];

    cur_memtotal_kb = mi->field.nr_total_pages * page_k;
    cur_swaptotal_kb = mi->field.total_swap * page_k;

    base_swaptotal_kb = (int64_t)property_get_int32("ro.slmk.base_swaptotal", 0) * 1024;

    if(base_swaptotal_kb == 0) {
        if(cur_memtotal_kb > 4194304 && cur_swaptotal_kb > 4194304) {  // ram 6GB ~
            base_swaptotal_kb = 4194304;
        } else if(cur_memtotal_kb <= 4194304 && cur_swaptotal_kb > 2621440) { // ram 3,4GB
            base_swaptotal_kb = 2621440;
        } else if(cur_memtotal_kb <= 2621440 && cur_swaptotal_kb > 2097152) { // ram 1,2GB
            base_swaptotal_kb = 2097152;
        } else {
            return false;
        }
    }

    target_swaptotal_kb = (100 - prev_swap_free_low_percentage) / 100.0 * base_swaptotal_kb;
    origin_swap_free_low_percentage = clamp(1, 100,(int)((1 - (float)target_swaptotal_kb / (float)cur_swaptotal_kb + 0.001) * 100));

    if(cur_swaptotal_kb > 4194304) {
        target_swaptotal_kb = (cur_swaptotal_kb - 4194304)*0.9 + target_swaptotal_kb;
    }
    swap_free_low_percentage = clamp(1, 100,(int)((1 - (float)target_swaptotal_kb / (float)cur_swaptotal_kb + 0.001) * 100));

    ALOGI("get cur_swaptotal : %" PRId64 ", prev_swaptotal : %" PRId64 "", cur_swaptotal_kb, base_swaptotal_kb);
    ALOGI("get prev_swap_free_low_percentage : %d, new_swap_free_low_percentage : %d", prev_swap_free_low_percentage, swap_free_low_percentage );

    snprintf(swapfreelow_str, PROPERTY_VALUE_MAX, "%d", swap_free_low_percentage);
    property_set("sys.lmk.slmk_new_swap_free_low", swapfreelow_str);
    return true;
}

static void check_memtotal(){

    int64_t memtotal = 0;

    static const char* const meminfo_memtotal_names[1] = { 
        "MemTotal:", 
    };
    static struct reread_data file_data = {
        .filename = MEMINFO_PATH,
        .fd = -1,
    };
    char *buf;
    char *save_ptr;
    char *line;

    if ((buf = reread_file(&file_data)) == NULL) {
        ALOGE("can't read meminfo");
        return;
    }

    for (line = strtok_r(buf, "\n", &save_ptr); line;
        line = strtok_r(NULL, "\n", &save_ptr)) {
        char *cp = line;
        char *ap;
        char *save_ptr_line;
        int64_t val;
        int field_idx;
        enum field_match_result match_res;
        
        cp = strtok_r(line, " ", &save_ptr_line);
        if (!cp) {
            ALOGE("meminfo parse error!");
            return;
        }
        ap = strtok_r(NULL, " ", &save_ptr_line);

        if (!ap) {
            ALOGE("meminfo parse error!");
            return;
        }
        
        match_res = match_field(cp, ap, meminfo_memtotal_names, 1,
        &val, &field_idx);
        
        if (match_res == PARSE_SUCCESS) {
            memtotal = val;
            break;
        } else if (match_res == PARSE_FAIL){
            ALOGE("meminfo parse error!");
            return;
        }
    }

    if( memtotal > (int64_t)total_memory_limit * 1024) {
        downgrade_pressure =
            ( (int64_t)property_get_int32("ro.slmk.2nd.custom_sw_limit",
              (int64_t)property_get_int32("ro.slmk.custom_sw_limit", 505) ) / 5 );
        upgrade_pressure =
            (int64_t)property_get_int32("ro.slmk.2nd.upgrade_pressure",
            (int64_t)property_get_int32("ro.slmk.upgrade_pressure", 80) );
        lmkd_freelimit_val =
            (int64_t)property_get_int32("ro.slmk.2nd.freelimit_val",
            (int64_t)property_get_int32("ro.slmk.freelimit_val", 11) );
        lmkd_cached_proc_min =
            property_get_int32("ro.slmk.2nd.dha_cached_min",
            property_get_int32("ro.slmk.dha_cached_min", 4) );
        enable_upgrade_criadj =
            property_get_bool("ro.slmk.2nd.enable_upgrade_criadj",
            property_get_bool("ro.slmk.enable_upgrade_criadj", false) );
        use_camera_boost =
            property_get_bool("ro.slmk.2nd.use_camera_boost",
            property_get_bool("ro.slmk.use_camera_boost", true) );
        use_critical_kill_booster =
            property_get_bool("ro.slmk.2nd.use_crikill_booster",
            property_get_bool("ro.slmk.use_crikill_booster", true) );
        use_camera_8k_boost =
            property_get_bool("ro.slmk.2nd.use_camera_8k_boost",
            property_get_bool("ro.slmk.use_camera_8k_boost", true) );
        use_dr_kill_boost =
            property_get_bool("ro.slmk.2nd.use_drkill_boost",
            property_get_bool("ro.slmk.use_drkill_boost", true) );
        camera_killboost_time =
            property_get_int32("ro.slmk.2nd.camera_killboost_time",
            property_get_int32("ro.slmk.camera_killboost_time", LAUNCHED_CAMERA_MEMBOOST_TIME) );
        lowmem_keep_except_limit_val =
            property_get_int32("ro.slmk.2nd.lowmem_limit_val",
            property_get_int32("ro.slmk.lowmem_limit_val", 0) ); // if value is 0, set_lowmem_keep_except_limit_val being excute.
        swap_free_low_percentage = 
            clamp(0, 100, property_get_int32("ro.slmk.2nd.swap_free_low_percentage",
            property_get_int32("ro.slmk.swap_free_low_percentage",DEF_LOW_SWAP)));
        if( property_get_bool("ro.slmk.2nd.enable_killbooster_all",
            property_get_bool("ro.slmk.enable_killbooster_all", false) ) ){
            use_camera_boost = true;
            use_camera_8k_boost = true;
            use_critical_kill_booster = true;
            use_dr_kill_boost = true;
            ALOGI("lmkd enable_killbooster_all");
        }
    } else {
        downgrade_pressure =
            ( (int64_t)property_get_int32("ro.slmk.custom_sw_limit", 505) / 5 );
        upgrade_pressure =
            (int64_t)property_get_int32("ro.slmk.upgrade_pressure", 80);
        lmkd_freelimit_val =
            (int64_t)property_get_int32("ro.slmk.freelimit_val", 11);
        lmkd_cached_proc_min =
            property_get_int32("ro.slmk.dha_cached_min", 4);
        enable_upgrade_criadj =
            property_get_bool("ro.slmk.enable_upgrade_criadj", false);
        use_camera_boost =
            property_get_bool("ro.slmk.use_camera_boost", true);
        use_critical_kill_booster = 
            property_get_bool("ro.slmk.use_crikill_booster", true);
        use_camera_8k_boost =
            property_get_bool("ro.slmk.use_camera_8k_boost", true);
        use_dr_kill_boost =
            property_get_bool("ro.slmk.use_drkill_boost", true);
        camera_killboost_time =
            property_get_int32("ro.slmk.camera_killboost_time", LAUNCHED_CAMERA_MEMBOOST_TIME);
        lowmem_keep_except_limit_val =
            property_get_int32("ro.slmk.lowmem_limit_val", 0); // if value is 0, set_lowmem_keep_except_limit_val being excute.
        swap_free_low_percentage = 
            clamp(0, 100, property_get_int32("ro.slmk.swap_free_low_percentage",DEF_LOW_SWAP));
        if( property_get_bool("ro.slmk.enable_killbooster_all", false) ) {
            use_camera_boost = true;
            use_camera_8k_boost = true;
            use_critical_kill_booster = true;
            use_dr_kill_boost = true;
            ALOGI("lmkd enable_killbooster_all");
        }
    }
    
    if ( memtotal < (int64_t)extra_under_memory_th_for_tuning * 1024) {
        if (extra_tuning_lmk_custom_sw_limit > 0)     downgrade_pressure = (int64_t)(extra_tuning_lmk_custom_sw_limit / 5);
        if (extra_tuning_lmk_upgrade_pressure > 0)    upgrade_pressure = extra_tuning_lmk_upgrade_pressure;
        if (extra_tuning_lmk_freelimit_val > 0)       lmkd_freelimit_val = extra_tuning_lmk_freelimit_val;
        if (extra_tuning_min_cached_apps > 0)         lmkd_cached_proc_min = extra_tuning_min_cached_apps;
    } else if ( memtotal > (int64_t)extra_over_memory_th_for_tuning * 1024) {
        if (extra_tuning_lmk_custom_sw_limit > 0)     downgrade_pressure = (int64_t)(extra_tuning_lmk_custom_sw_limit / 5);
        if (extra_tuning_lmk_upgrade_pressure > 0)    upgrade_pressure = extra_tuning_lmk_upgrade_pressure;
        if (extra_tuning_lmk_freelimit_val > 0)       lmkd_freelimit_val = extra_tuning_lmk_freelimit_val;
        if (extra_tuning_min_cached_apps > 0)         lmkd_cached_proc_min = extra_tuning_min_cached_apps;
    }

    if( downgrade_pressure > 100 ){
        downgrade_pressure =
           (int64_t)property_get_int32("ro.slmk.downgrade_pressure", 100);
    }

    if (memtotal > 8 * 1024000) { // 12GB~16GB
        use_camera_kill_mode_noswaprss = false;
    }
    ALOGI("set custom_sw_limit : %" PRId64 " ", downgrade_pressure * 5 );
    ALOGI("set upgrade_pressure : %" PRId64 " ", upgrade_pressure );
    ALOGI("set lmkd_freelimit_val : %" PRId64 " ", lmkd_freelimit_val );
    ALOGI("enable_upgrade_criadj : %d", enable_upgrade_criadj );

    set_lowmem_keep_except_limit_val(memtotal, lowmem_keep_except_limit_val);

    set_camera_default_kill_size(memtotal);
}

static bool init_mp_psi(enum vmpressure_level level, bool use_new_strategy) {
    int fd;

    /* Do not register a handler if threshold_ms is not set */
    if (!psi_thresholds[level].threshold_ms) {
        return true;
    }

    fd = init_psi_monitor(psi_thresholds[level].stall_type,
        psi_thresholds[level].threshold_ms * US_PER_MS,
        psi_window_size_ms * US_PER_MS);

    if (fd < 0) {
        return false;
    }

    vmpressure_hinfo[level].handler = use_new_strategy ? mp_event_psi : mp_event_common;
    vmpressure_hinfo[level].data = level;
    if (register_psi_monitor(epollfd, fd, &vmpressure_hinfo[level]) < 0) {
        destroy_psi_monitor(fd);
        return false;
    }
    maxevents++;
    mpevfd[level] = fd;

    return true;
}

static void destroy_mp_psi(enum vmpressure_level level) {
    int fd = mpevfd[level];

    if (fd < 0) {
        return;
    }

    if (unregister_psi_monitor(epollfd, fd) < 0) {
        ALOGE("Failed to unregister psi monitor for %s memory pressure; errno=%d",
            level_name[level], errno);
    }
    maxevents--;
    destroy_psi_monitor(fd);
    mpevfd[level] = -1;
}

static bool init_psi_monitors() {
    /*
     * When PSI is used on low-ram devices or on high-end devices without memfree levels
     * use new kill strategy based on zone watermarks, free swap and thrashing stats
     */
    bool use_new_strategy =
        property_get_bool("ro.slmk.use_new_strategy", low_ram_device || !use_minfree_levels);
    if (force_use_old_strategy)
	    use_new_strategy = false;

    /* In default PSI mode override stall amounts using system properties */
    if (use_new_strategy) {
        /* Do not use low pressure level */
        psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = 0;
        psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms = psi_partial_stall_ms;
        psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms = psi_morepartial_stall_ms;
        psi_thresholds[VMPRESS_LEVEL_SUPER_CRITICAL].threshold_ms = psi_complete_stall_ms;
    } else {
        if(!use_minfree_levels){
            psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = PSI_OLD_LOW_THRESH_MS;
        } else {
            psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = 0;
        }
        psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms = PSI_OLD_MED_THRESH_MS;
        psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms = PSI_OLD_CRIT_THRESH_MS;
    }

    if (!init_mp_psi(VMPRESS_LEVEL_LOW, use_new_strategy)) {
        return false;
    }
    if (!init_mp_psi(VMPRESS_LEVEL_MEDIUM, use_new_strategy)) {
        destroy_mp_psi(VMPRESS_LEVEL_LOW);
        return false;
    }
    if (!init_mp_psi(VMPRESS_LEVEL_CRITICAL, use_new_strategy)) {
        destroy_mp_psi(VMPRESS_LEVEL_MEDIUM);
        destroy_mp_psi(VMPRESS_LEVEL_LOW);
        return false;
    }
    if (use_new_strategy && !init_mp_psi(VMPRESS_LEVEL_SUPER_CRITICAL, use_new_strategy)) {
        destroy_mp_psi(VMPRESS_LEVEL_CRITICAL);
        destroy_mp_psi(VMPRESS_LEVEL_MEDIUM);
        destroy_mp_psi(VMPRESS_LEVEL_LOW);
        return false;
    }
    return true;
}

static bool init_mp_common(enum vmpressure_level level) {
    int mpfd;
    int evfd;
    int evctlfd;
    char buf[256];
    struct epoll_event epev;
    int ret;
    int level_idx = (int)level;
    const char *levelstr = level_name[level_idx];

    /* gid containing AID_SYSTEM required */
    mpfd = open(MEMCG_SYSFS_PATH "memory.pressure_level", O_RDONLY | O_CLOEXEC);
    if (mpfd < 0) {
        ALOGI("No kernel memory.pressure_level support (errno=%d)", errno);
        goto err_open_mpfd;
    }

    evctlfd = open(MEMCG_SYSFS_PATH "cgroup.event_control", O_WRONLY | O_CLOEXEC);
    if (evctlfd < 0) {
        ALOGI("No kernel memory cgroup event control (errno=%d)", errno);
        goto err_open_evctlfd;
    }

    evfd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
    if (evfd < 0) {
        ALOGE("eventfd failed for level %s; errno=%d", levelstr, errno);
        goto err_eventfd;
    }

    ret = snprintf(buf, sizeof(buf), "%d %d %s", evfd, mpfd, levelstr);
    if (ret >= (ssize_t)sizeof(buf)) {
        ALOGE("cgroup.event_control line overflow for level %s", levelstr);
        goto err;
    }

    ret = TEMP_FAILURE_RETRY(write(evctlfd, buf, strlen(buf) + 1));
    if (ret == -1) {
        ALOGE("cgroup.event_control write failed for level %s; errno=%d",
              levelstr, errno);
        goto err;
    }

    epev.events = EPOLLIN;
    /* use data to store event level */
    vmpressure_hinfo[level_idx].data = level_idx;
    vmpressure_hinfo[level_idx].handler = mp_event_common;
    epev.data.ptr = (void *)&vmpressure_hinfo[level_idx];
    ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, evfd, &epev);
    if (ret == -1) {
        ALOGE("epoll_ctl for level %s failed; errno=%d", levelstr, errno);
        goto err;
    }
    maxevents++;
    mpevfd[level] = evfd;
    close(evctlfd);
    return true;

err:
    close(evfd);
err_eventfd:
    close(evctlfd);
err_open_evctlfd:
    close(mpfd);
err_open_mpfd:
    return false;
}

static void destroy_mp_common(enum vmpressure_level level) {
    struct epoll_event epev;
    int fd = mpevfd[level];

    if (fd < 0) {
        return;
    }

    if (epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &epev)) {
        // Log an error and keep going
        ALOGE("epoll_ctl for level %s failed; errno=%d", level_name[level], errno);
    }
    maxevents--;
    close(fd);
    mpevfd[level] = -1;
}

static void kernel_event_handler(int data __unused, uint32_t events __unused,
                                 struct polling_params *poll_params __unused) {
    poll_kernel(kpoll_fd);
}

static bool init_monitors() {
    /* Try to use psi monitor first if kernel has it */
    use_psi_monitors = property_get_bool("ro.slmk.use_psi", true) &&
        init_psi_monitors();
    /* Fall back to vmpressure */
    if (lmkd_freelimit_enable && !use_minfree_levels){
        if (!use_psi_monitors &&
            (!init_mp_common(VMPRESS_LEVEL_MEDIUM) ||
            !init_mp_common(VMPRESS_LEVEL_CRITICAL))) {
            ALOGE("Kernel does not support memory pressure events or in-kernel low memory killer");
            return false;
        }
    } else {
        if (!use_psi_monitors &&
            (!init_mp_common(VMPRESS_LEVEL_LOW) ||
            !init_mp_common(VMPRESS_LEVEL_MEDIUM) ||
            !init_mp_common(VMPRESS_LEVEL_CRITICAL))) {
            ALOGE("Kernel does not support memory pressure events or in-kernel low memory killer");
            return false;
        }
    }
    if (use_psi_monitors) {
        ALOGI("Using psi monitors for memory pressure detection");
    } else {
        ALOGI("Using vmpressure for memory pressure detection");
    }
    return true;
}

static void destroy_monitors() {
    if (use_psi_monitors) {
        destroy_mp_psi(VMPRESS_LEVEL_SUPER_CRITICAL);
        destroy_mp_psi(VMPRESS_LEVEL_CRITICAL);
        destroy_mp_psi(VMPRESS_LEVEL_MEDIUM);
        destroy_mp_psi(VMPRESS_LEVEL_LOW);
    } else {
        destroy_mp_common(VMPRESS_LEVEL_CRITICAL);
        destroy_mp_common(VMPRESS_LEVEL_MEDIUM);
        destroy_mp_common(VMPRESS_LEVEL_LOW);
    }
}

static void update_psi_window_size() {
    union meminfo info;

    if (force_use_old_strategy) {
	    if (!meminfo_parse(&info)) {
		    /*
		     * Set the optimal settings for lowram targets.
		     */
		    if (info.field.nr_total_pages < (int64_t)(SZ_4G / PAGE_SIZE)) {
			    if (psi_window_size_ms > 500) {
				    psi_window_size_ms = 500;
				    ULMK_LOG(I, "PSI window size is changed to %dms\n", psi_window_size_ms);
			    }
			    if (psi_poll_period_scrit_ms < PSI_POLL_PERIOD_LONG_MS) {
				    psi_poll_period_scrit_ms = PSI_POLL_PERIOD_LONG_MS;
				    ULMK_LOG(I, "PSI poll period for super critical event is changed to %dms\n",psi_poll_period_scrit_ms);
			    }
		    }
	    } else
		    ULMK_LOG(E, "Failed to parse the meminfo\n");
    }
    /*
     * Ensure min polling period for supercritical event is no less than
     * PSI_POLL_PERIOD_SHORT_MS.
     */
    if (psi_poll_period_scrit_ms < PSI_POLL_PERIOD_SHORT_MS)
	    psi_poll_period_scrit_ms = PSI_POLL_PERIOD_SHORT_MS;
}

static int init(void) {
    static struct event_handler_info kernel_poll_hinfo = { 0, kernel_event_handler };
    struct reread_data file_data = {
        .filename = ZONEINFO_PATH,
        .fd = -1,
    };
    struct epoll_event epev;
    int pidfd;
    int i;
    int ret;

    page_k = sysconf(_SC_PAGESIZE);
    if (page_k == -1)
        page_k = PAGE_SIZE;
    page_k /= 1024;

    if(use_qc_feature) { // QC Code
        update_psi_window_size();
    }

    epollfd = epoll_create(MAX_EPOLL_EVENTS);
    if (epollfd == -1) {
        ALOGE("epoll_create failed (errno=%d)", errno);
        return -1;
    }

    // mark data connections as not connected
    for (int i = 0; i < MAX_DATA_CONN; i++) {
        data_sock[i].sock = -1;
    }

    ctrl_sock.sock = android_get_control_socket("lmkd");
    if (ctrl_sock.sock < 0) {
        ALOGE("get lmkd control socket failed");
        return -1;
    }

    ret = listen(ctrl_sock.sock, MAX_DATA_CONN);
    if (ret < 0) {
        ALOGE("lmkd control socket listen failed (errno=%d)", errno);
        return -1;
    }

    epev.events = EPOLLIN;
    ctrl_sock.handler_info.handler = ctrl_connect_handler;
    epev.data.ptr = (void *)&(ctrl_sock.handler_info);
    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_sock.sock, &epev) == -1) {
        ALOGE("epoll_ctl for lmkd control socket failed (errno=%d)", errno);
        return -1;
    }
    maxevents++;

    has_inkernel_module = !access(INKERNEL_MINFREE_PATH, W_OK);
    use_inkernel_interface = has_inkernel_module && !enable_userspace_lmk;

    if (use_inkernel_interface) {
        ALOGI("Using in-kernel low memory killer interface");
        if (init_poll_kernel()) {
            epev.events = EPOLLIN;
            epev.data.ptr = (void*)&kernel_poll_hinfo;
            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, kpoll_fd, &epev) != 0) {
                ALOGE("epoll_ctl for lmk events failed (errno=%d)", errno);
                close(kpoll_fd);
                kpoll_fd = -1;
            } else {
                maxevents++;
                /* let the others know it does support reporting kills */
                property_set("sys.lmk.reportkills", "1");
            }
        }
    } else {
        if (!init_monitors()) {
            return -1;
        }
        /* let the others know it does support reporting kills */
        property_set("sys.lmk.reportkills", "1");

        check_memtotal();
    }

    for (i = 0; i <= ADJTOSLOT(OOM_SCORE_ADJ_MAX); i++) {
        procadjslot_list[i].next = &procadjslot_list[i];
        procadjslot_list[i].prev = &procadjslot_list[i];
    }

    memset(killcnt_idx, KILLCNT_INVALID_IDX, sizeof(killcnt_idx));

    /*
     * Read zoneinfo as the biggest file we read to create and size the initial
     * read buffer and avoid memory re-allocations during memory pressure
     */
    if (reread_file(&file_data) == NULL) {
        ALOGE("Failed to read %s: %s", file_data.filename, strerror(errno));
    }

    /* check if kernel supports pidfd_open syscall */
    pidfd = TEMP_FAILURE_RETRY(sys_pidfd_open(getpid(), 0));
    if (pidfd < 0) {
        pidfd_supported = (errno != ENOSYS);
    } else {
        pidfd_supported = true;
        close(pidfd);
    }
    ALOGI("Process polling is %s", pidfd_supported ? "supported" : "not supported" );

    return 0;
}

static bool polling_paused(struct polling_params *poll_params) {
    return poll_params->paused_handler != NULL;
}

static void resume_polling(struct polling_params *poll_params, struct timespec curr_tm) {
    poll_params->poll_start_tm = curr_tm;
    poll_params->poll_handler = poll_params->paused_handler;
    poll_params->polling_interval_ms = PSI_POLL_PERIOD_SHORT_MS;
    poll_params->paused_handler = NULL;
}

static void call_handler(struct event_handler_info* handler_info,
                         struct polling_params *poll_params, uint32_t events) {
    struct timespec curr_tm;

    poll_params->update = POLLING_DO_NOT_CHANGE;
    handler_info->handler(handler_info->data, events, poll_params);
    clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm);
    if (poll_params->poll_handler == handler_info) {
        poll_params->last_poll_tm = curr_tm;
    }

    switch (poll_params->update) {
    case POLLING_START:
        /*
         * Poll for the duration of PSI_WINDOW_SIZE_MS after the
         * initial PSI event because psi events are rate-limited
         * at one per sec.
         */
        poll_params->poll_start_tm = curr_tm;
        poll_params->poll_handler = handler_info;
        break;
    case POLLING_PAUSE:
        poll_params->paused_handler = handler_info;
        poll_params->poll_handler = NULL;
        break;
    case POLLING_RESUME:
        resume_polling(poll_params, curr_tm);
        break;
    case POLLING_DO_NOT_CHANGE:
        if (poll_params->poll_handler &&
                get_time_diff_ms(&poll_params->poll_start_tm, &curr_tm) > psi_window_size_ms) {
            /* Polled for the duration of PSI window, time to stop */
            poll_params->poll_handler = NULL;
            //poll_params->paused_handler = NULL;
            s_crit_event = false;
        }
        break;
    }
}

static bool have_psi_events(struct epoll_event *evt, int nevents)
{
	int i;
	struct event_handler_info* handler_info;

	for (i = 0; i < nevents; i++, evt++) {
		if (evt->events & (EPOLLERR | EPOLLHUP))
			continue;
		if (evt->data.ptr) {
			handler_info = (struct event_handler_info*)evt->data.ptr;
			if (handler_info->handler == mp_event_common)
				return true;
		}
	}

	return false;
}

static void check_cont_lmkd_events(int lvl)
{
	static struct timespec tmed, tcrit, tupgrad;
	struct timespec now, prev;

	clock_gettime(CLOCK_MONOTONIC_COARSE, &now);

	if (lvl == VMPRESS_LEVEL_MEDIUM) {
		prev = tmed;
		tmed = now;
	}else {
		prev = tcrit;
		tcrit = now;
	}

	/*
	 * Consider it as contiguous if two successive medium/critical events fall
	 * in window + 1/2(window) period.
	 */
	if (get_time_diff_ms(&prev, &now) < ((psi_window_size_ms * 3) >> 1)) {
		if (get_time_diff_ms(&tupgrad, &now) > psi_window_size_ms) {
			if (last_event_upgraded) {
				count_upgraded_event++;
				last_event_upgraded = false;
				tupgrad = now;
			} else {
				count_upgraded_event = 0;
			}
		}
	} else {
		count_upgraded_event = 0;
	}
}

static void mainloop(void) {
    struct event_handler_info* handler_info;
    struct polling_params poll_params;
    struct timespec curr_tm;
    struct epoll_event *evt;
    long delay = -1;

    poll_params.poll_handler = NULL;
    poll_params.paused_handler = NULL;
    union vmstat poll1, poll2;

    memset(&poll1, 0, sizeof(union vmstat));
    memset(&poll2, 0, sizeof(union vmstat));
    while (1) {
        struct epoll_event events[MAX_EPOLL_EVENTS];
        int nevents;
        int i;
	bool skip_call_handler = false;

        if (poll_params.poll_handler) {
            bool poll_now;

            clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm);
            if (poll_params.update == POLLING_RESUME) {
                /* Just transitioned into POLLING_RESUME, poll immediately. */
                poll_now = true;
                nevents = 0;
            } else {
                /* Calculate next timeout */
                delay = get_time_diff_ms(&poll_params.last_poll_tm, &curr_tm);
                delay = (delay < poll_params.polling_interval_ms) ?
                    poll_params.polling_interval_ms - delay : poll_params.polling_interval_ms;

                /* Wait for events until the next polling timeout */
                nevents = epoll_wait(epollfd, events, maxevents, delay);

                /* Update current time after wait */
                clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm);
                poll_now = (get_time_diff_ms(&poll_params.last_poll_tm, &curr_tm) >=
                    poll_params.polling_interval_ms);
            }
            if (poll_now) {
		if (force_use_old_strategy) {
			if (s_crit_event) {
				vmstat_parse(&poll2);
				if ((nevents > 0 && have_psi_events(events, nevents)) ||
				    (!(poll2.field.pgscan_direct - poll1.field.pgscan_direct) &&
				    !(poll2.field.pgscan_kswapd - poll1.field.pgscan_kswapd) &&
				    !(poll2.field.pgscan_direct_throttle - poll1.field.pgscan_direct_throttle)))
					skip_call_handler = true;
				poll1 = poll2;
			}
		}
		if (!skip_call_handler)
			call_handler(poll_params.poll_handler, &poll_params, 0);
            }
        } else {
            if (kill_timeout_ms && is_waiting_for_kill()) {
                clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm);
                delay = kill_timeout_ms - get_time_diff_ms(&last_kill_tm, &curr_tm);
                /* Wait for pidfds notification or kill timeout to expire */
                nevents = (delay > 0) ? epoll_wait(epollfd, events, maxevents, delay) : 0;
                if (nevents == 0) {
                    /* Kill notification timed out */
                    stop_wait_for_proc_kill(false);
                    if (polling_paused(&poll_params)) {
                        clock_gettime(CLOCK_MONOTONIC_COARSE, &curr_tm);
                        poll_params.update = POLLING_RESUME;
                        resume_polling(&poll_params, curr_tm);
                    }
                }
            } else {
                /* Wait for events with no timeout */
                nevents = epoll_wait(epollfd, events, maxevents, -1);
            }
        }

        if (nevents == -1) {
            if (errno == EINTR)
                continue;
            ALOGE("epoll_wait failed (errno=%d)", errno);
            continue;
        }

        /*
         * First pass to see if any data socket connections were dropped.
         * Dropped connection should be handled before any other events
         * to deallocate data connection and correctly handle cases when
         * connection gets dropped and reestablished in the same epoll cycle.
         * In such cases it's essential to handle connection closures first.
         */
        for (i = 0, evt = &events[0]; i < nevents; ++i, evt++) {
            if ((evt->events & EPOLLHUP) && evt->data.ptr) {
                ALOGI("lmkd data connection dropped");
                handler_info = (struct event_handler_info*)evt->data.ptr;
                ctrl_data_close(handler_info->data);
            }
        }

        /* Second pass to handle all other events */
        for (i = 0, evt = &events[0]; i < nevents; ++i, evt++) {
            if (evt->events & EPOLLERR) {
                ALOGD("EPOLLERR on event #%d", i);
            }
            if (evt->events & EPOLLHUP) {
                /* This case was handled in the first pass */
                continue;
            }
            if (evt->data.ptr) {
                handler_info = (struct event_handler_info*)evt->data.ptr;
		if (force_use_old_strategy && handler_info->handler == mp_event_common &&
			(handler_info->data == VMPRESS_LEVEL_MEDIUM ||
			  handler_info->data == VMPRESS_LEVEL_CRITICAL)) {
			check_cont_lmkd_events(handler_info->data);
		}
                call_handler(handler_info, &poll_params, evt->events);
            }
        }
    }
}

void set_custom_property() {
    enhance_batch_kill =
        property_get_bool("ro.slmk.enhance_batch_kill", false);
    enable_adaptive_lmk =
        property_get_bool("ro.slmk.enable_adaptive_lmk", false);
    enable_userspace_lmk =
        property_get_bool("ro.slmk.enable_userspace_lmk", true);
    enable_watermark_check =
        property_get_bool("ro.slmk.enable_watermark_check", false);
    enable_preferred_apps =
        property_get_bool("ro.lmk.enable_preferred_apps", false);
    enable_proc_get_script =
        property_get_bool("ro.slmk.enable_proc_get_script", false);

    enable_cmarbinfree_sub =
        property_get_bool("ro.slmk.enable_cmarbinfree_sub", true);
    lmkd_cached_proc_min =
        property_get_int32("ro.slmk.dha_cached_min", 4);

    enable_reentry_lmk = true;

    enable_upgrade_criadj =
        property_get_bool("ro.slmk.enable_upgrade_criadj", false);
    total_memory_limit = 
        property_get_int32("ro.slmk.dha_2ndprop_thMB", 4096);
    /* extra RAM size tuning value */
    extra_under_memory_th_for_tuning = 
        property_get_int32("ro.slmk.3rd.under_thMB", 0);
    extra_over_memory_th_for_tuning = 
        property_get_int32("ro.slmk.3rd.over_thMB", 9999999);
    extra_tuning_lmk_upgrade_pressure = 
        (int64_t)property_get_int32("ro.slmk.3rd.upgrade_pressure", 0);
    extra_tuning_lmk_custom_sw_limit = 
        (int64_t)property_get_int32("ro.slmk.3rd.custom_sw_limit", 0);
    extra_tuning_lmk_freelimit_val = 
        (int64_t)property_get_int32("ro.slmk.3rd.freelimit_val", 0);
    extra_tuning_min_cached_apps = 
        property_get_int32("ro.slmk.3rd.dha_cached_min", 0);
    // encrypt downgrade pressure
    downgrade_pressure =
        ( (int64_t)property_get_int32("ro.slmk.custom_sw_limit", 505) / 5 );
    if( downgrade_pressure > 100 ){
        downgrade_pressure =
            (int64_t)property_get_int32("ro.slmk.downgrade_pressure", 100);
    }
    // encrypt ro.slmk.kill_timeout_ms Property
    kill_timeout_ms =
        ( (unsigned long)property_get_int32("ro.slmk.custom_tm_limit", 1000) / 10 );
    kill_timeout_ms_ori = kill_timeout_ms;
    lmkd_freelimit_enable =
        property_get_bool("ro.slmk.freelimit_enable", true);
    lmkd_freelimit_val =
        (int64_t)property_get_int32("ro.slmk.freelimit_val", 11);

    psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = 
        property_get_int32("ro.slmk.psi_low", 70);
    psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms = 
        property_get_int32("ro.slmk.psi_medium", low_ram_device ? DEF_PARTIAL_STALL_LOWRAM : DEF_PARTIAL_STALL);
    psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms = 
        property_get_int32("ro.slmk.psi_critical", DEF_MOREPARTIAL_STALL);
    psi_thresholds[VMPRESS_LEVEL_SUPER_CRITICAL].threshold_ms = 
        property_get_int32("ro.slmk.psi_real_critical", DEF_COMPLETE_STALL);

    psi_partial_stall_ms = property_get_int32("ro.slmk.psi_partial_stall_ms",
        psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms);
    psi_morepartial_stall_ms = property_get_int32("ro.slmk.psi_morepartial_stall_ms",
        psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms);
    psi_complete_stall_ms = property_get_int32("ro.slmk.psi_complete_stall_ms",
        psi_thresholds[VMPRESS_LEVEL_SUPER_CRITICAL].threshold_ms);

    use_lowmem_keep_except = 
        property_get_bool("ro.slmk.use_lowmem_keep_except", true);

    use_critical_kill_booster = 
        property_get_bool("ro.slmk.use_crikill_booster", true);

    use_camera_boost = 
        property_get_bool("ro.slmk.use_camera_boost", true);

    use_camera_8k_boost = 
        property_get_bool("ro.slmk.use_camera_8k_boost", true);

    use_dr_kill_boost = 
        property_get_bool("ro.slmk.use_drkill_boost", true);

    use_light_dr_killbooster = 
        property_get_bool("ro.slmk.use_light_drkill_boost", false);

    camera_killboost_time =
        property_get_int32("ro.slmk.camera_killboost_time", LAUNCHED_CAMERA_MEMBOOST_TIME);

    if( property_get_bool("ro.slmk.enable_killbooster_all", false) ) {
        use_camera_boost = true;
        use_camera_8k_boost = true;
        use_critical_kill_booster = true;
        use_dr_kill_boost = true;
    }

    use_camera_kill_mode = 
        ( property_get_int32("ro.slmk.cam_dha_ver", 0) > 1 ) ? true : false;

    use_camera_kill_mode_light = (property_get_int32("ro.slmk.cam_dha_ver", 0) & 4);

    use_camera_kill_mode_light_v2 = (property_get_int32("ro.slmk.cam_dha_ver", 0) & 8);

    use_camera_kill_mode_noswaprss = (property_get_int32("ro.slmk.cam_dha_ver", 0) & 16);

    camera_kill_start_tm = property_get_int32("ro.slmk.cam_kill_start_minutes", 0) * 1000 * 60;

    bora_policy_enable =
        property_get_bool("ro.slmk.bora_policy_enable", false);

    use_bg_keeping_policy =
        property_get_bool("ro.slmk.use_bg_keeping_policy", false);

    use_bg_keeping_policy_light =
        property_get_bool("ro.slmk.use_bg_keeping_policy_light", false);

    low_cachemem_deadline_page_zone_on_off =
        property_get_bool("ro.slmk.c_deadline_zone_on_off",true);

    use_bg_keeping_adapt_tm =
        property_get_bool("ro.slmk.use_bg_keeping_adapt_tm", true);

    if(is_check_model_name) is_check_model_name = false;

    if (clock_gettime(CLOCK_MONOTONIC_COARSE, &boot_tm) != 0) {
        ALOGE("Failed to get current time (boot time) in update_props");
        return;
    }
}

int issue_reinit() {
    int sock;

    sock = lmkd_connect();
    if (sock < 0) {
        ALOGE("failed to connect to lmkd: %s", strerror(errno));
        return -1;
    }

    enum update_props_result res = lmkd_update_props(sock);
    switch (res) {
    case UPDATE_PROPS_SUCCESS:
        ALOGI("lmkd updated properties successfully");
        break;
    case UPDATE_PROPS_SEND_ERR:
        ALOGE("failed to send lmkd request: %s", strerror(errno));
        break;
    case UPDATE_PROPS_RECV_ERR:
        ALOGE("failed to receive lmkd reply: %s", strerror(errno));
        break;
    case UPDATE_PROPS_FORMAT_ERR:
        ALOGE("lmkd reply is invalid");
        break;
    case UPDATE_PROPS_FAIL:
        ALOGE("lmkd failed to update its properties");
        break;
    }

    close(sock);
    return res == UPDATE_PROPS_SUCCESS ? 0 : -1;
}

/* Block QC Code
static void init_PreferredApps() {
    void *handle = NULL;
    handle = dlopen(IOPD_LIB, RTLD_NOW);
    if (handle != NULL) {
        perf_ux_engine_trigger = (void (*)(int, char *))dlsym(handle, "perf_ux_engine_trigger");

        if (!perf_ux_engine_trigger) {
            ALOGE("Couldn't obtain perf_ux_engine_trigger");
            enable_preferred_apps = false;
        } else {
            // Initialize preferred_apps
            preferred_apps = (char *) malloc ( PREFERRED_OUT_LENGTH * sizeof(char));
            if (preferred_apps == NULL) {
                enable_preferred_apps = false;
            } else {
                memset(preferred_apps, 0, PREFERRED_OUT_LENGTH);
                preferred_apps[0] = '\0';
            }
        }
    }
}

static void update_perf_props() {

    enable_watermark_check =
        property_get_bool("ro.lmk.enable_watermark_check", false);
    enable_preferred_apps =
        property_get_bool("ro.lmk.enable_preferred_apps", false);

     // Loading the vendor library at runtime to access property value //
     PropVal (*perf_get_prop)(const char *, const char *) = NULL;
     void *handle = NULL;
     handle = dlopen(PERFD_LIB, RTLD_NOW);
     if (handle != NULL)
         perf_get_prop = (PropVal (*)(const char *, const char *))dlsym(handle, "perf_get_prop");

     if(!perf_get_prop) {
          ALOGE("Couldn't get perf_get_prop function handle.");
     } else {
          char property[PROPERTY_VALUE_MAX];
          char default_value[PROPERTY_VALUE_MAX];

          //Currently only the following properties introduced by Google
          *are used outside. Hence their names are mirrored to _dup
          *If it doesnot get value via get_prop it will use the value
          *set by Google by default. To use the properties mentioned
          *above, same can be followed//
          strlcpy(default_value, (kill_heaviest_task)? "true" : "false", PROPERTY_VALUE_MAX);
          strlcpy(property, perf_get_prop("ro.lmk.kill_heaviest_task_dup", default_value).value, PROPERTY_VALUE_MAX);
          kill_heaviest_task = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;

          snprintf(default_value, PROPERTY_VALUE_MAX, "%lu", (kill_timeout_ms));
          strlcpy(property, perf_get_prop("ro.lmk.kill_timeout_ms_dup", default_value).value, PROPERTY_VALUE_MAX);
          kill_timeout_ms =  strtod(property, NULL);

          snprintf(default_value, PROPERTY_VALUE_MAX, "%d",
                    level_oomadj[VMPRESS_LEVEL_SUPER_CRITICAL]);
          strlcpy(property, perf_get_prop("ro.lmk.super_critical", default_value).value, PROPERTY_VALUE_MAX);
          level_oomadj[VMPRESS_LEVEL_SUPER_CRITICAL] = strtod(property, NULL);

          snprintf(default_value, PROPERTY_VALUE_MAX, "%d", direct_reclaim_pressure);
          strlcpy(property, perf_get_prop("ro.lmk.direct_reclaim_pressure", default_value).value, PROPERTY_VALUE_MAX);
          direct_reclaim_pressure = strtod(property, NULL);

	  snprintf(default_value, PROPERTY_VALUE_MAX, "%d", PSI_WINDOW_SIZE_MS);
	  strlcpy(property, perf_get_prop("ro.lmk.psi_window_size_ms", default_value).value, PROPERTY_VALUE_MAX);
	  psi_window_size_ms = strtod(property, NULL);

	  snprintf(default_value, PROPERTY_VALUE_MAX, "%d", PSI_SCRIT_COMPLETE_STALL_MS);
	  strlcpy(property, perf_get_prop("ro.lmk.psi_scrit_complete_stall_ms", default_value).value, PROPERTY_VALUE_MAX);
	  psi_thresholds[VMPRESS_LEVEL_SUPER_CRITICAL].threshold_ms = strtod(property, NULL);

	  snprintf(default_value, PROPERTY_VALUE_MAX, "%d", PSI_POLL_PERIOD_SHORT_MS);
	  strlcpy(property, perf_get_prop("ro.lmk.psi_poll_period_scrit_ms", default_value).value, PROPERTY_VALUE_MAX);
	  psi_poll_period_scrit_ms = strtod(property, NULL);

	  snprintf(default_value, PROPERTY_VALUE_MAX, "%d", reclaim_scan_threshold);
	  strlcpy(property, perf_get_prop("ro.lmk.reclaim_scan_threshold", default_value).value, PROPERTY_VALUE_MAX);
	  reclaim_scan_threshold = strtod(property, NULL);

          strlcpy(default_value, (use_minfree_levels)? "true" : "false", PROPERTY_VALUE_MAX);
          strlcpy(property, perf_get_prop("ro.lmk.use_minfree_levels_dup", default_value).value, PROPERTY_VALUE_MAX);
          use_minfree_levels = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;

          strlcpy(default_value, (force_use_old_strategy)? "true" : "false", PROPERTY_VALUE_MAX);
          strlcpy(property, perf_get_prop("ro.lmk.use_new_strategy_dup", default_value).value, PROPERTY_VALUE_MAX);
          force_use_old_strategy = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;

          //The following properties are not intoduced by Google
           *hence kept as it is //
          strlcpy(property, perf_get_prop("ro.lmk.enhance_batch_kill", "true").value, PROPERTY_VALUE_MAX);
          enhance_batch_kill = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;
          strlcpy(property, perf_get_prop("ro.lmk.enable_adaptive_lmk", "false").value, PROPERTY_VALUE_MAX);
          enable_adaptive_lmk = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;
          strlcpy(property, perf_get_prop("ro.lmk.enable_userspace_lmk", "false").value, PROPERTY_VALUE_MAX);
          enable_userspace_lmk = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;
          strlcpy(property, perf_get_prop("ro.lmk.enable_watermark_check", "false").value, PROPERTY_VALUE_MAX);
          enable_watermark_check = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;
          strlcpy(property, perf_get_prop("ro.lmk.enable_preferred_apps", "false").value, PROPERTY_VALUE_MAX);
          enable_preferred_apps = (!strncmp(property,"false",PROPERTY_VALUE_MAX))? false : true;

          //Update kernel interface during re-init.
          use_inkernel_interface = has_inkernel_module && !enable_userspace_lmk;
	  update_psi_window_size();
    }

    // Load IOP library for PApps //
    if (enable_preferred_apps) {
        init_PreferredApps();
    }
}
*/
static void update_props() {
    /* Ignore SIGPIPE */
    signal(SIGPIPE, SIG_IGN);

    /* By default disable low level vmpressure events */
    level_oomadj[VMPRESS_LEVEL_LOW] =
        property_get_int32("ro.slmk.low", OOM_SCORE_ADJ_MAX + 1);
    level_oomadj[VMPRESS_LEVEL_MEDIUM] =
        property_get_int32("ro.slmk.medium", 850);
    level_oomadj[VMPRESS_LEVEL_CRITICAL] =
        property_get_int32("ro.slmk.critical", 0);
    /* This will gets updated through perf_get_prop. */
    //level_oomadj[VMPRESS_LEVEL_SUPER_CRITICAL] = 606;
    debug_process_killing = property_get_bool("ro.slmk.debug", false);

    /* By default disable upgrade/downgrade logic */
    enable_pressure_upgrade =
        property_get_bool("ro.slmk.critical_upgrade", false);
    upgrade_pressure =
        (int64_t)property_get_int32("ro.slmk.upgrade_pressure", 80);
    downgrade_pressure =
        (int64_t)property_get_int32("ro.slmk.downgrade_pressure", 100);
    kill_heaviest_task =
        property_get_bool("ro.slmk.kill_heaviest_task", true);
    low_ram_device = property_get_bool("ro.config.low_ram", false);
    kill_timeout_ms =
        (unsigned long)property_get_int32("ro.slmk.kill_timeout_ms", 100);
    kill_timeout_ms_med =
        (unsigned long)property_get_int32("ro.slmk.kill_timeout_ms", 1000);
    kill_timeout_ms_ori = kill_timeout_ms;
    use_minfree_levels =
        property_get_bool("ro.slmk.use_minfree_levels", false);
    per_app_memcg =
        property_get_bool("ro.config.per_app_memcg", low_ram_device);
    swap_free_low_percentage = clamp(0, 100, property_get_int32("ro.slmk.swap_free_low_percentage",
        DEF_LOW_SWAP));
#ifdef LMKD_CHIMERA
    chimera_swap_free_percentage_ths = clamp(0, 100,
    property_get_int32("ro.cfg.chimera_swap_free_percentage_ths", 80));
    chimera_enabled = property_get_bool("persist.config.chimera.enable", false);
    clock_gettime(CLOCK_MONOTONIC_COARSE, &chimera_last_start_tm);
    ALOGD("fetch chimera enabled flag :[%d] from property ", chimera_enabled);
    chimera_kill_interval = property_get_int32("ro.cfg.chimera_kill_interval", 5000);
#endif
    psi_partial_stall_ms = property_get_int32("ro.slmk.psi_partial_stall_ms",
        low_ram_device ? DEF_PARTIAL_STALL_LOWRAM : DEF_PARTIAL_STALL);
    psi_morepartial_stall_ms = property_get_int32("ro.slmk.psi_morepartial_stall_ms",
        DEF_MOREPARTIAL_STALL);
    psi_complete_stall_ms = property_get_int32("ro.slmk.psi_complete_stall_ms",
        DEF_COMPLETE_STALL);
    thrashing_limit_pct = max(0, property_get_int32("ro.slmk.thrashing_limit",
        low_ram_device ? DEF_THRASHING_LOWRAM : DEF_THRASHING));
    thrashing_limit_decay_pct = clamp(0, 100, property_get_int32("ro.slmk.thrashing_limit_decay",
        low_ram_device ? DEF_THRASHING_DECAY_LOWRAM : DEF_THRASHING_DECAY));
    thrashing_critical_pct = max(0, property_get_int32("ro.slmk.thrashing_limit_critical",
        thrashing_limit_pct * 2));
    swap_util_max = clamp(0, 100, property_get_int32("ro.slmk.swap_util_max", 100));
    filecache_min_kb = property_get_int64("ro.slmk.filecache_min_kb", 0);

    enable_change_picked_adj = property_get_bool("ro.slmk.enable_change_picked_adj", false);

    set_custom_property();

    /* Block QC Code
    // Update Perf Properties
    update_perf_props();
    */
}

/* disable mediatek patch
LMKD_CTRL_PACKET ppacket;
*/
int main(int argc, char **argv) {
    /* disable mediatek patch
    int val = 0;
    ppacket[2] = -1;
    */
    if ((argc > 1) && argv[1] && !strcmp(argv[1], "--reinit")) {
        if (property_set(LMKD_REINIT_PROP, "")) {
            ALOGE("Failed to reset " LMKD_REINIT_PROP " property");
        }
        return issue_reinit();
    }
    if ((argc > 1) && argv[1] && !strcmp(argv[1], "--update")) {
        /* disable mediatek patch
        ALOGI("lmkd update param -begin %s  val %s  (pid=%d)", argv[2], argv[3], getpid());
        if (argv[3]) {
            val = atoi(argv[3]);
            if(!strcmp(argv[2], "thrashinglimit")) {
                if(val > 0 && val <= 100) {
                    ppacket[1]=0;
                    ppacket[2]=val;
                }
            }else if(!strcmp(argv[2], "swaplow")) {
                if(val > 0 && val <= 100) {
                    ppacket[1]=1;
                    ppacket[2]=val;
                }
            }else if(!strcmp(argv[2], "killtimeout")) {
                if(val > 0 && val <= 1000) {
                    ppacket[1]=2;
                    ppacket[2]=val;
                }
            }
        }
        if(ppacket[2] == -1)
            return 0;
        else
            return issue_reinit();
        */
        return 0;
    }

    update_props();

    ctx = create_android_logger(KILLINFO_LOG_TAG);

    if (!init()) {
        if (!use_inkernel_interface) {
            /*
             * MCL_ONFAULT pins pages as they fault instead of loading
             * everything immediately all at once. (Which would be bad,
             * because as of this writing, we have a lot of mapped pages we
             * never use.) Old kernels will see MCL_ONFAULT and fail with
             * EINVAL; we ignore this failure.
             *
             * N.B. read the man page for mlockall. MCL_CURRENT | MCL_ONFAULT
             * pins ?? MCL_CURRENT, converging to just MCL_CURRENT as we fault
             * in pages.
             */
            /* CAP_IPC_LOCK required */
            if (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) && (errno != EINVAL)) {
                ALOGW("mlockall failed %s", strerror(errno));
            }

            /* CAP_NICE required */
            struct sched_param param = {
                    .sched_priority = 1,
            };
            if (sched_setscheduler(0, SCHED_FIFO, &param)) {
                ALOGW("set SCHED_FIFO failed %s", strerror(errno));
            }
        }

        mainloop();
    } else {
        enable_userspace_lmk = false;
    }

    android_log_destroy(&ctx);

    ALOGI("exiting");
    return 0;
}
